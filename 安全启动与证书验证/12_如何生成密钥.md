# 如何生成密钥（Key Generation）

## 概述

在 ARM Trusted Firmware 中，虽然没有独立的 `create_key` 工具，但有多种方式可以生成密钥：

1. **使用 cert_create 工具**（TF-A 内置，推荐）
2. **使用 OpenSSL 命令**（最常用）
3. **使用 cert_create 的自动生成功能**

---

## 方法一：使用 OpenSSL（最常用）

### 1. 生成 RSA 密钥

#### RSA 2048 位密钥（推荐用于 TF-A）

```bash
# 生成私钥（PEM 格式）
openssl genrsa -out private_key.pem 2048

# 生成私钥（DER 格式）
openssl genrsa -out private_key.der 2048 -outform DER

# 生成私钥并设置密码保护
openssl genrsa -aes256 -out private_key.pem 2048
```

#### RSA 4096 位密钥（更高安全性）

```bash
openssl genrsa -out private_key.pem 4096
```

### 2. 生成 ECDSA 密钥

#### ECDSA P-256（secp256r1）

```bash
# 生成私钥（PEM 格式）
openssl ecparam -genkey -name prime256v1 -out ecdsa_private_key.pem

# 或者使用新式命令
openssl genpkey -algorithm EC -pkeyopt ec_paramgen_curve:P-256 -out ecdsa_private_key.pem
```

#### ECDSA P-384（secp384r1）

```bash
openssl ecparam -genkey -name secp384r1 -out ecdsa_private_key.pem

# 或者
openssl genpkey -algorithm EC -pkeyopt ec_paramgen_curve:P-384 -out ecdsa_private_key.pem
```

#### ECDSA P-521（secp521r1）

```bash
openssl ecparam -genkey -name secp521r1 -out ecdsa_private_key.pem

# 或者
openssl genpkey -algorithm EC -pkeyopt ec_paramgen_curve:P-521 -out ecdsa_private_key.pem
```

### 3. 使用通用命令生成密钥

```bash
# RSA 密钥
openssl genpkey -algorithm RSA -out rsa_key.pem -pkeyopt rsa_keygen_bits:2048

# ECDSA 密钥
openssl genpkey -algorithm EC -out ecdsa_key.pem -pkeyopt ec_paramgen_curve:P-256
```

### 4. 密钥格式转换

```bash
# PEM 转 DER
openssl pkey -in private_key.pem -out private_key.der -outform DER

# DER 转 PEM
openssl pkey -in private_key.der -inform DER -out private_key.pem -outform PEM
```

---

## 方法二：使用 cert_create 工具（TF-A）

### 1. 自动生成密钥

`cert_create` 工具可以通过 `--new-keys` 选项自动生成所有需要的密钥：

```bash
# 编译 cert_create 工具
make PLAT=fvp certtool

# 使用 --new-keys 选项自动生成密钥
cert_create \
    --new-keys \
    --save-keys \
    --key-alg rsa \
    --key-size 2048 \
    --hash-alg sha256 \
    --trusted-key-cert trusted_key.crt \
    --rot-key rot_key.pem \
    ...
```

**参数说明**：
- `--new-keys`: 如果密钥文件不存在，自动生成新密钥
- `--save-keys`: 将生成的密钥保存到文件
- `--key-alg rsa/ecdsa`: 指定密钥算法
- `--key-size 2048/384`: 指定密钥大小

### 2. 通过 Makefile 生成

```bash
# 设置 CREATE_KEYS=1 启用自动密钥生成
make PLAT=fvp CREATE_KEYS=1 all fip

# 这会自动调用 cert_create 并生成所有需要的密钥
```

**Makefile 中的处理**（Makefile 第 516-519 行）：

```makefile
ifneq (${CREATE_KEYS},0)
    $(eval CRT_ARGS += -n)  # -n 对应 --new-keys
    $(eval FWU_CRT_ARGS += -n)
    $(eval BL2_CRT_ARGS += -n)
endif
```

### 3. cert_create 支持的密钥类型

**key.c 第 186-196 行**：

```c
static const key_create_fn_t key_create_fn[KEY_ALG_MAX_NUM] = {
    [KEY_ALG_RSA] = key_create_rsa,
    [KEY_ALG_ECDSA_NIST] = key_create_ecdsa_nist,
    [KEY_ALG_ECDSA_BRAINPOOL_R] = key_create_ecdsa_brainpool_r,
    [KEY_ALG_ECDSA_BRAINPOOL_T] = key_create_ecdsa_brainpool_t,
};
```

支持的算法：
- **RSA**: 任意位数（通常 2048 或 4096）
- **ECDSA NIST**: P-256 (256位) 或 P-384 (384位)
- **ECDSA Brainpool**: brainpoolP256r1, brainpoolP256t1

---

## 方法三：生成 TF-A 所需的所有密钥

### 1. 完整的密钥生成脚本

```bash
#!/bin/bash
# generate_tf_a_keys.sh

KEY_DIR="./keys"
mkdir -p ${KEY_DIR}

# 密钥算法和大小
KEY_ALG="rsa"
KEY_SIZE="2048"

# 生成 Root of Trust Key
openssl genrsa -out ${KEY_DIR}/rot_key.pem ${KEY_SIZE}

# 生成 Trusted World Key
openssl genrsa -out ${KEY_DIR}/trusted_world_key.pem ${KEY_SIZE}

# 生成 Non-Trusted World Key
openssl genrsa -out ${KEY_DIR}/non_trusted_world_key.pem ${KEY_SIZE}

# 生成 SCP Firmware Content Certificate Key
openssl genrsa -out ${KEY_DIR}/scp_fw_content_key.pem ${KEY_SIZE}

# 生成 SoC Firmware Content Certificate Key (BL31)
openssl genrsa -out ${KEY_DIR}/soc_fw_content_key.pem ${KEY_SIZE}

# 生成 Trusted OS Firmware Content Certificate Key (BL32)
openssl genrsa -out ${KEY_DIR}/tos_fw_content_key.pem ${KEY_SIZE}

# 生成 Non-Trusted Firmware Content Certificate Key (BL33)
openssl genrsa -out ${KEY_DIR}/nt_fw_content_key.pem ${KEY_SIZE}

echo "All keys generated in ${KEY_DIR}/"
```

### 2. 使用 cert_create 生成所有密钥

```bash
cert_create \
    --new-keys \
    --save-keys \
    --key-alg rsa \
    --key-size 2048 \
    --hash-alg sha256 \
    --trusted-key-cert trusted_key.crt \
    --rot-key rot_key.pem \
    --trusted-world-key trusted_world_key.pem \
    --non-trusted-world-key non_trusted_world_key.pem \
    --scp-fw-key scp_fw_content_key.pem \
    --soc-fw-key soc_fw_content_key.pem \
    --tos-fw-key tos_fw_content_key.pem \
    --nt-fw-key nt_fw_content_key.pem \
    --scp-fw-key-cert scp_fw_key.crt \
    --scp-fw-cert scp_fw_content.crt \
    --soc-fw-key-cert soc_fw_key.crt \
    --soc-fw-cert soc_fw_content.crt \
    --tos-fw-key-cert tos_fw_key.crt \
    --tos-fw-cert tos_fw_content.crt \
    --nt-fw-key-cert nt_fw_key.crt \
    --nt-fw-cert nt_fw_content.crt
```

---

## 密钥类型说明

### TF-A TBBR 架构中的密钥

| 密钥名称 | 用途 | 命令行选项 |
|---------|------|-----------|
| **ROT_KEY** | Root of Trust Key，用于签名 Trusted Key Certificate | `--rot-key` |
| **TRUSTED_WORLD_KEY** | 用于签名 Trusted World 的 Key Certificate | `--trusted-world-key` |
| **NON_TRUSTED_WORLD_KEY** | 用于签名 Non-Trusted World 的 Key Certificate | `--non-trusted-world-key` |
| **SCP_FW_CONTENT_CERT_KEY** | 用于签名 SCP_BL2 的 Content Certificate | `--scp-fw-key` |
| **SOC_FW_CONTENT_CERT_KEY** | 用于签名 BL31 的 Content Certificate | `--soc-fw-key` |
| **TOS_FW_CONTENT_CERT_KEY** | 用于签名 BL32 的 Content Certificate | `--tos-fw-key` |
| **NT_FW_CONTENT_CERT_KEY** | 用于签名 BL33 的 Content Certificate | `--nt-fw-key` |

---

## 实际使用示例

### 示例 1：生成单个密钥

```bash
# 生成 ROT Key
openssl genrsa -out rot_key.pem 2048

# 生成 BL31 Content Certificate Key
openssl genrsa -out soc_fw_content_key.pem 2048
```

### 示例 2：使用 cert_create 自动生成

```bash
# 编译 cert_create
cd arm-trusted-firmware
make PLAT=fvp certtool

# 使用自动生成功能
build/fvp/release/tools/cert_create/cert_create \
    --new-keys \
    --save-keys \
    --key-alg rsa \
    --key-size 2048 \
    --trusted-key-cert build/fvp/release/trusted_key.crt \
    --rot-key build/fvp/release/rot_key.pem
```

### 示例 3：通过 Makefile 自动生成

```bash
# 设置 CREATE_KEYS=1，Makefile 会自动生成密钥
make PLAT=fvp CREATE_KEYS=1 all fip

# 生成的密钥会保存在 build/fvp/release/ 目录
```

---

## 密钥安全建议

### 1. 密钥存储

- ✅ **私钥必须保密**：不要将私钥提交到版本控制系统
- ✅ **使用密码保护**：生成密钥时使用 `-aes256` 选项
- ✅ **设置正确的文件权限**：
  ```bash
  chmod 600 private_key.pem
  ```

### 2. 密钥备份

```bash
# 备份密钥到安全位置
cp -p private_key.pem /secure/backup/location/
```

### 3. 密钥轮换

定期轮换密钥，特别是在密钥泄露的情况下。

---

## 常见问题

### Q1: 如何选择密钥算法和大小？

**RSA**：
- 2048 位：推荐用于大多数场景（TF-A 默认）
- 4096 位：更高安全性，但计算开销更大

**ECDSA**：
- P-256：256 位，相当于 RSA 3072 位
- P-384：384 位，相当于 RSA 7680 位
- P-521：521 位，相当于 RSA 15360 位

**TF-A 推荐**：
- RSA 2048 位（默认）
- ECDSA P-256 或 P-384

### Q2: cert_create 如何知道生成哪些密钥？

`cert_create` 根据证书定义自动确定需要哪些密钥：

```c
// tbb_key.c 中定义了所有需要的密钥
static cert_key_t def_keys[] = {
    [ROT_KEY] = { ... },
    [TRUSTED_WORLD_KEY] = { ... },
    [SOC_FW_CONTENT_CERT_KEY] = { ... },
    ...
};
```

### Q3: 如何验证生成的密钥？

```bash
# 查看密钥信息
openssl pkey -in private_key.pem -text -noout

# 验证密钥格式
openssl pkey -in private_key.pem -check

# 提取公钥验证
openssl pkey -in private_key.pem -pubout -out public_key.pem
```

### Q4: 密钥文件命名规范

TF-A 推荐的命名：
- `rot_key.pem` - Root of Trust Key
- `trusted_world_key.pem` - Trusted World Key
- `soc_fw_content_key.pem` - BL31 Content Certificate Key
- `tos_fw_content_key.pem` - BL32 Content Certificate Key
- `nt_fw_content_key.pem` - BL33 Content Certificate Key

---

## 总结

### 快速生成密钥的方法

1. **使用 OpenSSL（最简单）**：
   ```bash
   openssl genrsa -out private_key.pem 2048
   ```

2. **使用 cert_create 自动生成**：
   ```bash
   cert_create --new-keys --save-keys --key-alg rsa --key-size 2048 ...
   ```

3. **通过 Makefile**：
   ```bash
   make PLAT=fvp CREATE_KEYS=1 all fip
   ```

### 推荐流程

对于 TF-A 开发：

1. **开发阶段**：使用 `CREATE_KEYS=1` 自动生成测试密钥
2. **生产环境**：使用 OpenSSL 手动生成密钥，并妥善保管
3. **密钥管理**：使用密钥管理系统（HSM）存储生产密钥

---

**参考文档**：
- OpenSSL 文档：https://www.openssl.org/docs/
- TF-A 证书工具：`tools/cert_create/`
- TF-A Makefile：`Makefile` 第 516-519 行

# Key Certificate 和 Content Certificate 详解

## 目录
1. [概述](#概述)
2. [Key Certificate 详解](#key-certificate-详解)
3. [Content Certificate 详解](#content-certificate-详解)
4. [两者差异对比](#两者差异对比)
5. [验证流程](#验证流程)
6. [证书生成](#证书生成)
7. [总结](#总结)

---

## 概述

在 ARM Trusted Firmware (TF-A) 的 Trusted Board Boot (TBBR) 架构中，采用了**两层证书结构**来实现密钥管理和内容验证的分离：

```
Trusted Key Certificate (ROT)
    ↓
Key Certificate (密钥证书) ← 存储公钥
    ↓
Content Certificate (内容证书) ← 存储镜像 hash
    ↓
Firmware Image (固件镜像)
```

这种设计的优势：
- **密钥管理分离**：Key Certificate 负责公钥分发，Content Certificate 负责内容验证
- **灵活性**：可以独立更新 Content Certificate（重新签名镜像），无需修改 Key Certificate
- **安全性**：即使 Content Certificate 的私钥泄露，也只需要更新 Content Certificate

---

## Key Certificate 详解

### 1. 定义和用途

**Key Certificate（密钥证书）**用于分发公钥，用于验证下一级的 Content Certificate。

### 2. 证书内容

Key Certificate 在 X.509 扩展中存储：

- **下一级 Content Certificate 的公钥**（通过 X.509 扩展）
- **NV Counter**（防回滚计数器）

**示例：SOC_FW_KEY_CERT**

```c
// tbb_cert.c 第 79-91 行
[SOC_FW_KEY_CERT] = {
    .id = SOC_FW_KEY_CERT,
    .opt = "soc-fw-key-cert",
    .key = TRUSTED_WORLD_KEY,  // 签名密钥
    .ext = {
        TRUSTED_FW_NVCOUNTER_EXT,        // NV Counter
        SOC_FW_CONTENT_CERT_PK_EXT       // Content Cert 的公钥
    }
}
```

**代码中的定义（tbbr_cot_bl2.c 第 230-259 行）**：

```c
static const auth_img_desc_t soc_fw_key_cert = {
    .img_id = SOC_FW_KEY_CERT_ID,
    .parent = &trusted_key_cert,  // 父证书是 Trusted Key Cert
    .img_auth_methods = {
        [0] = {
            .type = AUTH_METHOD_SIG,
            .param.sig = {
                .pk = &trusted_world_pk,  // 用 Trusted World PK 验证
            }
        }
    },
    .authenticated_data = {
        [0] = {
            .type_desc = &soc_fw_content_pk,  // ← 存储 Content Cert 的公钥
            .data = {
                .ptr = (void *)content_pk_buf,
                .len = PK_DER_LEN
            }
        }
    }
};
```

### 3. 证书结构

```
SOC_FW_KEY_CERT (Key Certificate)
├─ Subject Public Key Info: 证书自己的公钥（用于验证证书签名）
├─ Signature: 由 Trusted World Key 签名
└─ X.509 Extensions:
    ├─ NV Counter Extension
    └─ SOC_FW_CONTENT_CERT_PK_EXT: Content Certificate 的公钥 ← 关键内容
```

### 4. 不包含的内容

- ❌ **不包含**镜像的 hash 值
- ❌ **不包含**镜像文件本身

---

## Content Certificate 详解

### 1. 定义和用途

**Content Certificate（内容证书）**用于存储固件镜像的 hash 值，用于验证镜像的完整性。

### 2. 证书内容

Content Certificate 在 X.509 扩展中存储：

- **下一级镜像的 hash 值**（通过 X.509 扩展）
- **配置文件的 hash 值**（如 SOC_FW_CONFIG）
- **NV Counter**（防回滚计数器）

**示例：SOC_FW_CONTENT_CERT**

```c
// tbb_cert.c 第 93-106 行
[SOC_FW_CONTENT_CERT] = {
    .id = SOC_FW_CONTENT_CERT,
    .opt = "soc-fw-cert",
    .key = SOC_FW_CONTENT_CERT_KEY,  // 签名密钥
    .ext = {
        TRUSTED_FW_NVCOUNTER_EXT,    // NV Counter
        SOC_AP_FW_HASH_EXT,          // BL31 的 hash
        SOC_FW_CONFIG_HASH_EXT,      // Config 的 hash
    }
}
```

**代码中的定义（tbbr_cot_bl2.c 第 261-299 行）**：

```c
static const auth_img_desc_t soc_fw_content_cert = {
    .img_id = SOC_FW_CONTENT_CERT_ID,
    .parent = &soc_fw_key_cert,  // 父证书是 Key Cert
    .img_auth_methods = {
        [0] = {
            .type = AUTH_METHOD_SIG,
            .param.sig = {
                .pk = &soc_fw_content_pk,  // 用 Key Cert 中的公钥验证
            }
        }
    },
    .authenticated_data = {
        [0] = {
            .type_desc = &soc_fw_hash,  // ← 存储 BL31 的 hash
            .data = {
                .ptr = (void *)soc_fw_hash_buf,
                .len = HASH_DER_LEN
            }
        },
        [1] = {
            .type_desc = &soc_fw_config_hash,  // ← 存储 Config 的 hash
            ...
        }
    }
};
```

### 3. 证书结构

```
SOC_FW_CONTENT_CERT (Content Certificate)
├─ Subject Public Key Info: 证书自己的公钥（用于验证证书签名）
├─ Signature: 由 SOC_FW_CONTENT_CERT_KEY 签名
└─ X.509 Extensions:
    ├─ NV Counter Extension
    ├─ SOC_AP_FW_HASH_EXT: BL31 镜像的 hash ← 关键内容
    └─ SOC_FW_CONFIG_HASH_EXT: Config 的 hash
```

### 4. 不包含的内容

- ❌ **不包含**用于验证下一级证书的公钥
- ❌ **不包含**镜像文件本身

---

## 两者差异对比

| 特性 | Key Certificate | Content Certificate |
|------|----------------|-------------------|
| **存储内容** | 下一级 Content Certificate 的公钥 | 下一级镜像的 hash 值 |
| **签名者** | Trusted World Key | Key Certificate 中公钥对应的私钥 |
| **验证对象** | Content Certificate | Firmware Image |
| **扩展类型** | `EXT_TYPE_PKEY` | `EXT_TYPE_HASH` |
| **更新频率** | 较低（密钥管理） | 较高（镜像更新） |
| **命令行选项** | `--soc-fw-key-cert` | `--soc-fw-cert` |
| **示例** | `SOC_FW_KEY_CERT` | `SOC_FW_CONTENT_CERT` |
| **用途** | 公钥分发中心 | 镜像完整性验证 |

### 关键区别总结

1. **内容不同**：
   - Key Certificate：存储**公钥**（用于验证 Content Certificate）
   - Content Certificate：存储**hash**（用于验证镜像）

2. **验证对象不同**：
   - Key Certificate：验证**Content Certificate**
   - Content Certificate：验证**Firmware Image**

3. **在证书链中的位置不同**：
   - Key Certificate：位于 Content Certificate **之前**
   - Content Certificate：位于镜像**之前**

---

## 验证流程

### 1. Key Certificate 的验证流程

#### 1.1 验证 Key Certificate 自身

**验证步骤**：

```
1. 加载 Key Certificate
   ↓
2. 从父证书（Trusted Key Cert）获取公钥
   - 使用 trusted_world_pk（从 Trusted Key Cert 的扩展中提取）
   ↓
3. 验证 Key Certificate 的签名
   - 使用 trusted_world_pk 验证签名
   - 验证证书的完整性
   ↓
4. 验证 NV Counter（防回滚）
   ↓
5. 提取 authenticated_data
   - 提取 soc_fw_content_pk（Content Cert 的公钥）
   - 存储到 content_pk_buf 缓冲区
   ↓
6. 验证完成
```

**代码位置**：
- `common/bl_common.c` 第 153-187 行：`load_auth_image_recursive()`
- `drivers/auth/auth_mod.c` 第 459-585 行：`auth_mod_verify_img()`
- `drivers/auth/auth_mod.c` 第 130-201 行：`auth_signature()`

#### 1.2 验证下一级 Content Certificate

**验证步骤**：

```
1. 使用 Key Certificate 中提取的公钥
   - 使用 soc_fw_content_pk（从 Key Cert 的 authenticated_data 中获取）
   ↓
2. 加载 Content Certificate
   ↓
3. 验证 Content Certificate 的签名
   - 使用 soc_fw_content_pk 验证 Content Cert 的签名
   ↓
4. 验证完成
```

**代码位置**：
- `drivers/auth/auth_mod.c` 第 207-214 行：从父证书获取公钥
- `drivers/auth/auth_mod.c` 第 130-201 行：使用公钥验证签名

### 2. Content Certificate 的验证流程

#### 2.1 验证 Content Certificate 自身

**验证步骤**：

```
1. 加载 Content Certificate
   ↓
2. 从父证书（Key Cert）获取公钥
   - 使用 soc_fw_content_pk（从 Key Cert 的扩展中提取）
   ↓
3. 验证 Content Certificate 的签名
   - 使用 soc_fw_content_pk 验证签名
   - 验证证书的完整性
   ↓
4. 验证 NV Counter（防回滚）
   ↓
5. 提取 authenticated_data
   - 提取 soc_fw_hash（BL31 的 hash）
   - 提取 soc_fw_config_hash（Config 的 hash）
   - 存储到对应的缓冲区
   ↓
6. 验证完成
```

**代码位置**：
- `common/bl_common.c` 第 153-187 行：`load_auth_image_recursive()`
- `drivers/auth/auth_mod.c` 第 459-585 行：`auth_mod_verify_img()`
- `drivers/auth/auth_mod.c` 第 207-214 行：从父证书获取公钥

#### 2.2 验证下一级镜像（BL31）

**验证步骤**：

```
1. 使用 Content Certificate 中提取的 hash
   - 使用 soc_fw_hash（从 Content Cert 的 authenticated_data 中获取）
   ↓
2. 加载 BL31 镜像
   ↓
3. 计算 BL31 镜像的实际 hash
   - 使用相同的 hash 算法（SHA256/SHA384/SHA512）
   ↓
4. 比较 hash 值
   - 期望值：soc_fw_hash（从 Content Cert 中提取）
   - 实际值：计算得到的 hash
   - 两者必须完全匹配
   ↓
5. 验证完成
```

**代码位置**：
- `drivers/auth/auth_mod.c` 第 90-127 行：`auth_hash()`
- `drivers/auth/auth_mod.c` 第 100 行：从父证书获取 hash
- `drivers/auth/auth_mod.c` 第 109-115 行：从镜像提取 hash
- `drivers/auth/auth_mod.c` 第 118-124 行：比较 hash

**关键代码片段**：

```c
// drivers/auth/auth_mod.c 第 90-127 行
static int auth_hash(const auth_method_param_hash_t *param,
                     const auth_img_desc_t *img_desc,
                     void *img, unsigned int img_len)
{
    /* 从父证书（Content Cert）获取期望的 hash */
    rc = auth_get_param(param->hash, img_desc->parent,
                        &hash_der_ptr, &hash_der_len);
    
    /* 从当前镜像提取实际的 hash */
    rc = img_parser_get_auth_param(img_desc->img_type, param->data,
            img, img_len, &data_ptr, &data_len);
    
    /* 比较 hash */
    rc = crypto_mod_verify_hash(data_ptr, data_len,
                                hash_der_ptr, hash_der_len);
    return rc;
}
```

### 3. 完整验证流程示例（BL31）

```
时间轴：验证 BL31 镜像的完整流程

T1: load_auth_image(BL31_IMAGE_ID) 被调用
    ↓
T2: 递归加载 Trusted Key Cert
    - 验证签名（使用 ROTPK）
    - 提取 trusted_world_pk
    ↓
T3: 加载 Key Cert (SOC_FW_KEY_CERT)
    - 验证签名（使用 trusted_world_pk）
    - 提取 soc_fw_content_pk（Content Cert 的公钥）
    ↓
T4: 加载 Content Cert (SOC_FW_CONTENT_CERT)
    - 验证签名（使用 soc_fw_content_pk）
    - 提取 soc_fw_hash（BL31 的 hash）
    ↓
T5: 加载 BL31 镜像
    - 计算实际 hash
    - 与 soc_fw_hash 比较
    ↓
T6: 验证完成
```

---

## 证书生成

### 1. Key Certificate 的生成

#### 1.1 命令行参数

```bash
cert_create \
    --soc-fw-key-cert build/fvp/soc_fw_key.crt \      # 输出文件
    --soc-fw-key build/fvp/soc_fw_content_key.pem \   # 密钥文件（用于提取公钥）
    --trusted-world-key build/fvp/trusted_world_key.pem \  # 签名密钥
    ...
```

#### 1.2 生成过程

```
1. 解析命令行参数
   - --soc-fw-key-cert → 找到 SOC_FW_KEY_CERT 定义
   ↓
2. 加载密钥文件
   - --soc-fw-key → 加载 soc_fw_content_key.pem
   ↓
3. 处理扩展
   - EXT_TYPE_PKEY: 从密钥中提取公钥
   - 调用 ext_new_key() 创建公钥扩展
   ↓
4. 创建证书
   - 使用 trusted_world_key 签名
   - 添加公钥扩展到证书
   ↓
5. 保存证书文件
```

**代码位置**：
- `tools/cert_create/src/main.c` 第 534-537 行：处理 `EXT_TYPE_PKEY`
- `tools/cert_create/src/ext.c` 第 277-299 行：`ext_new_key()`

### 2. Content Certificate 的生成

#### 2.1 命令行参数

```bash
cert_create \
    --soc-fw-cert build/fvp/soc_fw_content.crt \      # 输出文件
    --soc-fw build/fvp/bl31.bin \                      # 镜像文件（用于计算 hash）
    --soc-fw-key build/fvp/soc_fw_content_key.pem \   # 签名密钥
    ...
```

#### 2.2 生成过程

```
1. 解析命令行参数
   - --soc-fw-cert → 找到 SOC_FW_CONTENT_CERT 定义
   ↓
2. 读取镜像文件
   - --soc-fw → 读取 bl31.bin
   ↓
3. 计算 hash
   - 使用指定的 hash 算法（SHA256/SHA384/SHA512）
   - 调用 sha_file() 计算镜像的 hash
   ↓
4. 处理扩展
   - EXT_TYPE_HASH: 创建 hash 扩展
   - 调用 ext_new_hash() 创建 hash 扩展
   ↓
5. 创建证书
   - 使用 soc_fw_content_key 签名
   - 添加 hash 扩展到证书
   ↓
6. 保存证书文件
```

**代码位置**：
- `tools/cert_create/src/main.c` 第 513-533 行：处理 `EXT_TYPE_HASH`
- `tools/cert_create/src/main.c` 第 524 行：`sha_file()` 计算 hash
- `tools/cert_create/src/ext.c` 第 181-226 行：`ext_new_hash()`

### 3. Makefile 中的配置

**tbbr_tools.mk 第 114-121 行**：

```makefile
ifeq (${NEED_BL31},yes)
# Add the BL31 CoT (key cert + img cert)
$(if ${BL31_KEY},$(eval $(call CERT_ADD_CMD_OPT,${BL31_KEY},--soc-fw-key)))
ifneq (${COT},cca)
$(eval $(call TOOL_ADD_PAYLOAD,${BUILD_PLAT}/soc_fw_content.crt,--soc-fw-cert))
$(eval $(call TOOL_ADD_PAYLOAD,${BUILD_PLAT}/soc_fw_key.crt,--soc-fw-key-cert))
endif
endif
```

**Makefile 第 1006 行**：

```makefile
$(if ${BL31}, $(eval $(call TOOL_ADD_IMG,bl31,--soc-fw,,$(ENCRYPT_BL31))))
```

这些配置会自动添加：
- `--soc-fw-key-cert` 和 `--soc-fw-cert` 到 `CRT_ARGS`
- `--soc-fw` 和镜像路径到 `CRT_ARGS`
- `--soc-fw-key` 和密钥路径到 `CRT_ARGS`

---

## 总结

### Key Certificate 和 Content Certificate 的核心区别

1. **内容**：
   - Key Certificate：存储**公钥**（用于验证 Content Certificate）
   - Content Certificate：存储**hash**（用于验证镜像）

2. **验证方式**：
   - Key Certificate：使用**公钥**验证 Content Certificate 的**签名**
   - Content Certificate：使用**hash**验证镜像的**完整性**

3. **在证书链中的位置**：
   - Key Certificate：位于 Content Certificate **之前**
   - Content Certificate：位于镜像**之前**

4. **生成方式**：
   - Key Certificate：从密钥文件中**提取公钥**
   - Content Certificate：从镜像文件中**计算 hash**

### 验证流程总结

```
Key Certificate 验证流程：
1. 验证自身：使用父证书的公钥验证签名
2. 提取公钥：提取下一级 Content Cert 的公钥
3. 验证下一级：使用提取的公钥验证 Content Cert 的签名

Content Certificate 验证流程：
1. 验证自身：使用父证书（Key Cert）的公钥验证签名
2. 提取 hash：提取下一级镜像的 hash
3. 验证下一级：使用提取的 hash 验证镜像的完整性
```

### 设计优势

1. **职责分离**：密钥管理和内容验证分离，各司其职
2. **灵活性**：可以独立更新 Content Certificate，无需修改 Key Certificate
3. **安全性**：即使 Content Certificate 的私钥泄露，也只需要更新 Content Certificate
4. **可扩展性**：可以轻松添加新的镜像类型，只需添加对应的 Content Certificate

---

## 参考资料

- `drivers/auth/tbbr/tbbr_cot_bl2.c`：证书定义和 Chain of Trust
- `tools/cert_create/src/tbbr/tbb_cert.c`：证书生成配置
- `tools/cert_create/src/tbbr/tbb_ext.c`：扩展定义
- `common/bl_common.c`：证书加载和验证流程
- `drivers/auth/auth_mod.c`：认证模块实现

---

**文档版本**：1.0  
**最后更新**：2025年

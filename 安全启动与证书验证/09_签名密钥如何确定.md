# 签名密钥是如何确定的

## 概述

当您提供了多个密钥参数时，cert_create 如何确定使用哪个密钥来签名证书？答案是：**签名密钥来自 issuer（签发者）证书的密钥**。

---

## 签名密钥的确定机制

### 1. 代码逻辑

**cert.c 第 102-104 行和 138-139 行**：

```c
int cert_new(...)
{
    // 1. 获取当前证书的密钥（用于 Subject Public Key）
    EVP_PKEY *pkey = keys[cert->key].key;
    
    // 2. 获取 issuer（签发者）证书
    cert_t *issuer_cert = &certs[cert->issuer];
    
    // 3. 从 issuer 证书获取签名密钥
    EVP_PKEY *ikey = keys[issuer_cert->key].key;  // ← 签名密钥来自这里
    
    // ...
    
    // 4. 使用 issuer 的私钥签名证书
    EVP_DigestSignInit(mdCtx, &pKeyCtx, get_digest(md_alg), NULL, ikey);
    // ...
    X509_sign_ctx(x, mdCtx);  // ← 签名证书
}
```

**关键点**：
- 签名密钥 = `keys[issuer_cert->key].key`
- `issuer_cert` = `certs[cert->issuer]`
- 所以签名密钥由 `cert->issuer` 字段指定的证书的 `.key` 字段决定

---

## 各证书的签名密钥

### 1. Trusted Key Certificate

**tbb_cert.c 第 36-43 行**：

```c
[TRUSTED_KEY_CERT] = {
    .key = ROT_KEY,              // ← Subject Public Key 使用 ROT_KEY
    .issuer = TRUSTED_KEY_CERT,  // ← issuer 是自己（自签名）
    ...
}
```

**签名密钥确定过程**：
```
1. cert->issuer = TRUSTED_KEY_CERT
2. issuer_cert = &certs[TRUSTED_KEY_CERT]
3. issuer_cert->key = ROT_KEY
4. 签名密钥 = keys[ROT_KEY].key  ← 使用 ROT_KEY 的私钥签名
```

**命令行参数**：
```bash
--rot-key rot_key.pem  # ← 这个密钥用于签名
```

---

### 2. SOC_FW_KEY_CERT

**tbb_cert.c 第 79-86 行**：

```c
[SOC_FW_KEY_CERT] = {
    .key = TRUSTED_WORLD_KEY,    // ← Subject Public Key 使用 TRUSTED_WORLD_KEY
    .issuer = SOC_FW_KEY_CERT,   // ← issuer 是自己（自签名）
    ...
}
```

**签名密钥确定过程**：
```
1. cert->issuer = SOC_FW_KEY_CERT
2. issuer_cert = &certs[SOC_FW_KEY_CERT]
3. issuer_cert->key = TRUSTED_WORLD_KEY
4. 签名密钥 = keys[TRUSTED_WORLD_KEY].key  ← 使用 TRUSTED_WORLD_KEY 的私钥签名
```

**命令行参数**：
```bash
--trusted-world-key trusted_world_key.pem  # ← 这个密钥用于签名
```

---

### 3. SOC_FW_CONTENT_CERT

**tbb_cert.c 第 93-100 行**：

```c
[SOC_FW_CONTENT_CERT] = {
    .key = SOC_FW_CONTENT_CERT_KEY,  // ← Subject Public Key 使用 SOC_FW_CONTENT_CERT_KEY
    .issuer = SOC_FW_CONTENT_CERT,   // ← issuer 是自己（自签名）
    ...
}
```

**签名密钥确定过程**：
```
1. cert->issuer = SOC_FW_CONTENT_CERT
2. issuer_cert = &certs[SOC_FW_CONTENT_CERT]
3. issuer_cert->key = SOC_FW_CONTENT_CERT_KEY
4. 签名密钥 = keys[SOC_FW_CONTENT_CERT_KEY].key  ← 使用 SOC_FW_CONTENT_CERT_KEY 的私钥签名
```

**命令行参数**：
```bash
--soc-fw-key soc_fw_content_key.pem  # ← 这个密钥用于签名
```

---

## 完整映射表

| 证书 | issuer 字段 | issuer 证书的 key | 签名密钥 | 命令行参数 |
|------|------------|------------------|---------|-----------|
| **TRUSTED_KEY_CERT** | TRUSTED_KEY_CERT（自签名） | ROT_KEY | `--rot-key` | `--rot-key rot_key.pem` |
| **TRUSTED_BOOT_FW_CERT** | TRUSTED_BOOT_FW_CERT（自签名） | ROT_KEY | `--rot-key` | `--rot-key rot_key.pem` |
| **SOC_FW_KEY_CERT** | SOC_FW_KEY_CERT（自签名） | TRUSTED_WORLD_KEY | `--trusted-world-key` | `--trusted-world-key trusted_world_key.pem` |
| **SCP_FW_KEY_CERT** | SCP_FW_KEY_CERT（自签名） | TRUSTED_WORLD_KEY | `--trusted-world-key` | `--trusted-world-key trusted_world_key.pem` |
| **TOS_FW_KEY_CERT** | TOS_FW_KEY_CERT（自签名） | TRUSTED_WORLD_KEY | `--trusted-world-key` | `--trusted-world-key trusted_world_key.pem` |
| **SOC_FW_CONTENT_CERT** | SOC_FW_CONTENT_CERT（自签名） | SOC_FW_CONTENT_CERT_KEY | `--soc-fw-key` | `--soc-fw-key soc_fw_content_key.pem` |
| **TOS_FW_CONTENT_CERT** | TOS_FW_CONTENT_CERT（自签名） | TOS_FW_CONTENT_CERT_KEY | `--tos-fw-key` | `--tos-fw-key tos_fw_content_key.pem` |
| **NT_FW_CONTENT_CERT** | NT_FW_CONTENT_CERT（自签名） | NT_FW_CONTENT_CERT_KEY | `--nt-fw-key` | `--nt-fw-key nt_fw_content_key.pem` |
| **NON_TRUSTED_FW_KEY_CERT** | NON_TRUSTED_FW_KEY_CERT（自签名） | NON_TRUSTED_WORLD_KEY | `--non-trusted-world-key` | `--non-trusted-world-key non_trusted_world_key.pem` |

---

## 关键规则

### 规则 1：签名密钥 = issuer 证书的密钥

```c
// cert.c 第 103-104 行
cert_t *issuer_cert = &certs[cert->issuer];
EVP_PKEY *ikey = keys[issuer_cert->key].key;  // ← 签名密钥
```

### 规则 2：自签名证书使用自己的密钥

在 TF-A TBBR 架构中，**所有证书都是自签名的**（`cert->issuer = cert->id`），所以：

- 签名密钥 = 证书自己的密钥
- 即：签名密钥 = `keys[cert->key].key`

**代码证据**（cert.c 第 126-130 行）：

```c
/* If we do not have an issuer certificate, use our own (the certificate
 * will become self signed) */
if (!issuer) {
    issuer = x;  // ← issuer 就是自己
}
```

### 规则 3：特殊情况处理

**cert.c 第 120-124 行**：

```c
/* If we do not have a key, use the issuer key (the certificate will
 * become self signed). This happens in content certificates. */
if (!pkey) {
    pkey = ikey;  // ← 如果没有指定密钥，使用 issuer 的密钥
}
```

---

## 实际示例

### 示例 1：生成 SOC_FW_KEY_CERT

**证书定义**：
```c
[SOC_FW_KEY_CERT] = {
    .key = TRUSTED_WORLD_KEY,    // ← Subject Public Key
    .issuer = SOC_FW_KEY_CERT,   // ← issuer 是自己
    ...
}
```

**签名密钥确定**：
```
1. cert->issuer = SOC_FW_KEY_CERT
2. issuer_cert = &certs[SOC_FW_KEY_CERT]
3. issuer_cert->key = TRUSTED_WORLD_KEY
4. 签名密钥 = keys[TRUSTED_WORLD_KEY].key
```

**命令行参数**：
```bash
cert_create \
    --trusted-world-key trusted_world_key.pem \  # ← 这个密钥用于签名
    --soc-fw-key-cert soc_fw_key.crt \
    ...
```

**结果**：
- Subject Public Key：`TRUSTED_WORLD_KEY` 的公钥
- 签名密钥：`TRUSTED_WORLD_KEY` 的私钥
- 扩展中的公钥：`SOC_FW_CONTENT_CERT_KEY` 的公钥（来自 `--soc-fw-key`）

---

### 示例 2：生成 SOC_FW_CONTENT_CERT

**证书定义**：
```c
[SOC_FW_CONTENT_CERT] = {
    .key = SOC_FW_CONTENT_CERT_KEY,  // ← Subject Public Key
    .issuer = SOC_FW_CONTENT_CERT,   // ← issuer 是自己
    ...
}
```

**签名密钥确定**：
```
1. cert->issuer = SOC_FW_CONTENT_CERT
2. issuer_cert = &certs[SOC_FW_CONTENT_CERT]
3. issuer_cert->key = SOC_FW_CONTENT_CERT_KEY
4. 签名密钥 = keys[SOC_FW_CONTENT_CERT_KEY].key
```

**命令行参数**：
```bash
cert_create \
    --soc-fw-key soc_fw_content_key.pem \  # ← 这个密钥用于签名
    --soc-fw-cert soc_fw_content.crt \
    ...
```

**结果**：
- Subject Public Key：`SOC_FW_CONTENT_CERT_KEY` 的公钥
- 签名密钥：`SOC_FW_CONTENT_CERT_KEY` 的私钥
- 扩展中的 hash：BL31 的 hash（来自 `--soc-fw bl31.bin`）

---

## 总结

### 签名密钥的确定规则

1. **查找 issuer 证书**：
   ```c
   cert_t *issuer_cert = &certs[cert->issuer];
   ```

2. **获取 issuer 证书的密钥**：
   ```c
   EVP_PKEY *ikey = keys[issuer_cert->key].key;
   ```

3. **使用 issuer 的私钥签名**：
   ```c
   EVP_DigestSignInit(mdCtx, &pKeyCtx, get_digest(md_alg), NULL, ikey);
   X509_sign_ctx(x, mdCtx);
   ```

### 对于自签名证书（TF-A 的情况）

由于所有证书都是自签名的（`cert->issuer = cert->id`），所以：

**签名密钥 = 证书自己的密钥 = `keys[cert->key].key`**

### 快速查找表

| 证书 | 签名密钥 | 命令行参数 |
|------|---------|-----------|
| TRUSTED_KEY_CERT | ROT_KEY | `--rot-key` |
| SOC_FW_KEY_CERT | TRUSTED_WORLD_KEY | `--trusted-world-key` |
| SOC_FW_CONTENT_CERT | SOC_FW_CONTENT_CERT_KEY | `--soc-fw-key` |
| TOS_FW_KEY_CERT | TRUSTED_WORLD_KEY | `--trusted-world-key` |
| TOS_FW_CONTENT_CERT | TOS_FW_CONTENT_CERT_KEY | `--tos-fw-key` |
| NT_FW_KEY_CERT | NON_TRUSTED_WORLD_KEY | `--non-trusted-world-key` |
| NT_FW_CONTENT_CERT | NT_FW_CONTENT_CERT_KEY | `--nt-fw-key` |

---

## 验证签名密钥

### 方法 1：查看证书的 Issuer 和 Signature

```bash
# 查看证书的 Issuer（签发者）
openssl x509 -in certificate.crt -text -noout | grep -A 1 "Issuer:"

# 查看证书的 Signature Algorithm
openssl x509 -in certificate.crt -text -noout | grep "Signature Algorithm"

# 验证签名（需要 issuer 的公钥）
openssl x509 -in certificate.crt -CAfile issuer_cert.crt -CAkey issuer_key.pem -verify
```

### 方法 2：查看证书定义

```bash
# 查看证书定义中的 issuer 字段
grep -A 10 "SOC_FW_KEY_CERT" tools/cert_create/src/tbbr/tbb_cert.c
```

---

**参考代码**：
- 证书定义：`tools/cert_create/src/tbbr/tbb_cert.c`
- 签名逻辑：`tools/cert_create/src/cert.c` 第 102-212 行

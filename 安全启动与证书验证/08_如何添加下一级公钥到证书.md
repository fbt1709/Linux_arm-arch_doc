# 如何将下一级证书的公钥添加到当前证书中

## 目录
1. [概述](#概述)
2. [实现方法](#实现方法)
3. [详细流程](#详细流程)
4. [实际使用示例](#实际使用示例)
5. [关键配置](#关键配置)
6. [完整流程总结](#完整流程总结)
7. [验证生成的证书](#验证生成的证书)
8. [注意事项](#注意事项)
9. [总结](#总结)

---

## 概述

要将下一级证书的公钥添加到当前证书中，实际上是在创建 **Key Certificate**。Key Certificate 的作用就是存储下一级 Content Certificate 的公钥。

---

## 实现方法

### 方法一：使用 cert_create 工具（推荐）

`cert_create` 工具会自动处理这个过程，您只需要：

1. **指定下一级证书的密钥文件**
2. **生成 Key Certificate**

#### 完整示例：生成 SOC_FW_KEY_CERT

```bash
cert_create \
    # Key Certificate 输出文件
    --soc-fw-key-cert build/fvp/soc_fw_key.crt \
    
    # 签名密钥（用于签名 Key Certificate）
    --trusted-world-key build/fvp/trusted_world_key.pem \
    
    # 下一级 Content Certificate 的密钥（公钥会被提取并添加到 Key Cert）
    --soc-fw-key build/fvp/soc_fw_content_key.pem \
    
    # 其他参数
    --key-alg rsa \
    --key-size 2048 \
    --hash-alg sha256 \
    --trusted-key-cert build/fvp/trusted_key.crt \
    ...
```

**工作原理**：

1. `cert_create` 读取 `--soc-fw-key` 指定的密钥文件
2. 从密钥中提取公钥
3. 根据证书定义（`SOC_FW_KEY_CERT`），自动添加 `SOC_FW_CONTENT_CERT_PK_EXT` 扩展
4. 将公钥编码为 DER 格式并添加到证书扩展中

---

## 详细流程

### 步骤 1：证书定义指定扩展类型

**tbb_cert.c 第 79-91 行**：

```c
[SOC_FW_KEY_CERT] = {
    .id = SOC_FW_KEY_CERT,
    .opt = "soc-fw-key-cert",
    .key = TRUSTED_WORLD_KEY,  // ← 签名密钥
    .ext = {
        TRUSTED_FW_NVCOUNTER_EXT,
        SOC_FW_CONTENT_CERT_PK_EXT  // ← 指定添加 Content Cert 的公钥扩展
    }
}
```

### 步骤 2：扩展定义关联密钥

**tbb_ext.c 第 116-123 行**：

```c
[SOC_FW_CONTENT_CERT_PK_EXT] = {
    .oid = SOC_FW_CONTENT_CERT_PK_OID,
    .type = EXT_TYPE_PKEY,                    // ← 类型：公钥扩展
    .attr.key = SOC_FW_CONTENT_CERT_KEY      // ← 关联的密钥 ID
}
```

### 步骤 3：cert_create 加载密钥

**main.c 第 392-395 行**：

```c
case CMD_OPT_KEY:
    cur_opt = cmd_opt_get_name(opt_idx);
    key = key_get_by_opt(cur_opt);  // ← 根据 --soc-fw-key 找到密钥定义
    key->fn = strdup(optarg);       // ← 保存密钥文件路径
```

**main.c 第 254-282 行** - 加载密钥：

```c
unsigned int key_load(cert_key_t *key)
{
    // 从文件加载私钥
    key->key = PEM_read_PrivateKey(fp, NULL, NULL, NULL);
    // 私钥中包含公钥信息
    return KEY_ERR_NONE;
}
```

### 步骤 4：处理公钥扩展

**main.c 第 534-537 行**：

```c
case EXT_TYPE_PKEY:
    CHECK_NULL(cert_ext, ext_new_key(ext_nid,
        EXT_CRIT, keys[ext->attr.key].key));  // ← 从已加载的密钥提取公钥
    break;
```

**ext.c 第 277-300 行** - `ext_new_key()`：

```c
X509_EXTENSION *ext_new_key(int nid, int crit, EVP_PKEY *k)
{
    /* 编码公钥为 DER 格式 */
    BIO *mem = BIO_new(BIO_s_mem());
    if (i2d_PUBKEY_bio(mem, k) <= 0) {  // ← 从私钥提取公钥并编码
        ERR_print_errors_fp(stderr);
        return NULL;
    }
    p = (unsigned char *)OPENSSL_malloc(4096);
    sz = BIO_read(mem, p, 4096);
    
    /* 创建 X.509 扩展 */
    ex = ext_new(nid, crit, p, sz);  // ← 创建公钥扩展
    return ex;
}
```

### 步骤 5：添加到证书

**main.c 第 544-546 行**：

```c
/* Push the extension into the stack */
sk_X509_EXTENSION_push(sk, cert_ext);  // ← 添加到证书扩展栈
```

---

## 实际使用示例

### 示例 1：生成 SOC_FW_KEY_CERT（包含 Content Cert 的公钥）

```bash
cert_create \
    # 输出文件
    --soc-fw-key-cert build/fvp/soc_fw_key.crt \
    
    # 签名密钥（用于签名 Key Certificate）
    --trusted-world-key build/fvp/trusted_world_key.pem \
    
    # 下一级 Content Certificate 的密钥
    # cert_create 会自动提取公钥并添加到 Key Certificate
    --soc-fw-key build/fvp/soc_fw_content_key.pem \
    
    # 算法参数
    --key-alg rsa \
    --key-size 2048 \
    --hash-alg sha256 \
    
    # 父证书（用于签名）
    --trusted-key-cert build/fvp/trusted_key.crt \
    
    # NV Counter
    --tfw-nvctr 0
```

**结果**：
- 生成 `soc_fw_key.crt`
- 证书中包含 `SOC_FW_CONTENT_CERT_PK_EXT` 扩展
- 扩展中存储了 `soc_fw_content_key.pem` 的公钥

### 示例 2：通过 Makefile 自动生成

**tbbr_tools.mk 第 117-120 行**：

```makefile
# 添加密钥文件参数
$(if ${BL31_KEY},$(eval $(call CERT_ADD_CMD_OPT,${BL31_KEY},--soc-fw-key)))

# 添加证书生成参数
$(eval $(call TOOL_ADD_PAYLOAD,${BUILD_PLAT}/soc_fw_content.crt,--soc-fw-cert))
$(eval $(call TOOL_ADD_PAYLOAD,${BUILD_PLAT}/soc_fw_key.crt,--soc-fw-key-cert))
```

**执行 `make PLAT=fvp all fip` 时**：

```bash
cert_create \
    --soc-fw-key build/fvp/soc_fw_content_key.pem \  # ← 自动添加
    --soc-fw-key-cert build/fvp/soc_fw_key.crt \
    ...
```

---

## 关键配置

### 1. 证书定义中指定扩展

**tbb_cert.c**：

```c
[YOUR_KEY_CERT] = {
    .id = YOUR_KEY_CERT,
    .opt = "your-key-cert",
    .key = PARENT_KEY,  // ← 签名密钥
    .ext = {
        TRUSTED_FW_NVCOUNTER_EXT,
        YOUR_CONTENT_CERT_PK_EXT  // ← 添加下一级证书的公钥扩展
    }
}
```

### 2. 扩展定义关联密钥

**tbb_ext.c**：

```c
[YOUR_CONTENT_CERT_PK_EXT] = {
    .oid = YOUR_CONTENT_CERT_PK_OID,
    .type = EXT_TYPE_PKEY,                    // ← 公钥类型
    .attr.key = YOUR_CONTENT_CERT_KEY         // ← 关联的密钥 ID
}
```

### 3. 密钥定义

**tbb_key.c**：

```c
[YOUR_CONTENT_CERT_KEY] = {
    .id = YOUR_CONTENT_CERT_KEY,
    .opt = "your-content-key",  // ← 命令行选项
    .desc = "Your Content Certificate key"
}
```

### 4. 命令行指定密钥文件

```bash
cert_create \
    --your-content-key your_content_key.pem \  # ← 指定密钥文件
    --your-key-cert your_key.crt \
    ...
```

---

## 完整流程总结

```
1. 准备下一级证书的密钥文件
   ↓
   your_content_key.pem
   ↓
2. 在证书定义中指定公钥扩展
   ↓
   YOUR_KEY_CERT.ext = { YOUR_CONTENT_CERT_PK_EXT }
   ↓
3. 在扩展定义中关联密钥
   ↓
   YOUR_CONTENT_CERT_PK_EXT.attr.key = YOUR_CONTENT_CERT_KEY
   ↓
4. 命令行指定密钥文件
   ↓
   --your-content-key your_content_key.pem
   ↓
5. cert_create 自动处理
   ↓
   - 加载密钥文件
   - 提取公钥
   - 创建公钥扩展
   - 添加到证书
   ↓
6. 生成包含公钥的 Key Certificate
   ↓
   your_key.crt（包含下一级证书的公钥）
```

---

## 验证生成的证书

### 查看证书中的公钥扩展

```bash
# 查看证书的扩展
openssl x509 -in soc_fw_key.crt -text -noout

# 查看特定扩展
openssl x509 -in soc_fw_key.crt -text -noout | grep -A 10 "SoCFirmwareContentCertPK"
```

### 提取扩展中的公钥

```bash
# 从证书中提取公钥扩展
openssl x509 -in soc_fw_key.crt -noout -extensions 1.3.6.1.4.1.4128.2100.601

# 或者使用 Python/OpenSSL 库提取
```

---

## 注意事项

### 1. 密钥文件必须存在

```bash
# 确保密钥文件存在
ls -l build/fvp/soc_fw_content_key.pem

# 如果不存在，使用 --new-keys 自动生成
cert_create --new-keys --soc-fw-key build/fvp/soc_fw_content_key.pem ...
```

### 2. 密钥类型必须匹配

- 如果下一级证书使用 RSA 密钥，Key Certificate 必须使用对应的 RSA 公钥
- 如果下一级证书使用 ECDSA 密钥，Key Certificate 必须使用对应的 ECDSA 公钥

### 3. 扩展 OID 必须唯一

```c
// 确保 OID 唯一
#define YOUR_CONTENT_CERT_PK_OID "1.3.6.1.4.1.4128.2100.XXX"
```

### 4. 证书签名密钥

Key Certificate 需要使用父证书的密钥签名：

```c
[SOC_FW_KEY_CERT] = {
    .key = TRUSTED_WORLD_KEY,  // ← 签名密钥
    .issuer = SOC_FW_KEY_CERT,
    ...
}
```

---

## 总结

### 如何将下一级证书的公钥添加到当前证书

1. **在证书定义中添加公钥扩展**：
   ```c
   .ext = { YOUR_CONTENT_CERT_PK_EXT }
   ```

2. **在扩展定义中关联密钥**：
   ```c
   .attr.key = YOUR_CONTENT_CERT_KEY
   ```

3. **命令行指定密钥文件**：
   ```bash
   --your-content-key your_content_key.pem
   ```

4. **cert_create 自动处理**：
   - 加载密钥文件
   - 提取公钥
   - 创建扩展
   - 添加到证书

### 关键点

- ✅ **不需要手动操作**：cert_create 会自动提取公钥并添加到证书
- ✅ **只需指定密钥文件**：通过 `--your-content-key` 选项指定
- ✅ **扩展类型必须是 `EXT_TYPE_PKEY`**：这样才能正确添加公钥
- ✅ **密钥必须已加载**：确保密钥文件存在或使用 `--new-keys` 生成

---

**参考代码**：
- 证书定义：`tools/cert_create/src/tbbr/tbb_cert.c` 第 79-91 行
- 扩展定义：`tools/cert_create/src/tbbr/tbb_ext.c` 第 116-123 行
- 公钥扩展创建：`tools/cert_create/src/ext.c` 第 277-300 行
- 证书生成：`tools/cert_create/src/main.c` 第 534-537 行

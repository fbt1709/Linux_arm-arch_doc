# 为什么平台将公钥编译为二进制文件

## 概述

在 ARM Trusted Firmware 中，某些平台会将 ROTPK（Root of Trust Public Key，信任根公钥）编译成二进制文件（`.bin`），然后通过汇编代码的 `.incbin` 指令将其嵌入到固件中。这种做法有多个重要原因。

---

## 原因分析

### 1. 安全性：信任根必须在编译时确定

**ROTPK 是信任链的起点**，必须：
- ✅ **编译时确定**：在固件编译时就已经确定，不能运行时修改
- ✅ **防篡改**：编译到固件中，成为固件的一部分，难以被恶意修改
- ✅ **不可替换**：一旦编译到固件中，就无法通过外部手段替换

**如果运行时加载**：
- ❌ 可能被恶意替换
- ❌ 需要额外的安全存储机制
- ❌ 增加了攻击面

### 2. 性能：避免运行时 I/O 操作

**编译到固件中的优势**：
- ✅ **零延迟**：公钥已经在内存中，无需读取外部存储
- ✅ **无 I/O 开销**：不需要打开文件、读取文件系统
- ✅ **确定性**：启动时间可预测

**如果运行时加载**：
- ❌ 需要访问 Flash/文件系统
- ❌ 增加启动时间
- ❌ 可能因为存储故障导致启动失败

### 3. 简化设计：无需外部存储依赖

**编译到固件中**：
- ✅ **自包含**：固件包含所有必要的信任根信息
- ✅ **无依赖**：不需要文件系统、Flash 驱动等
- ✅ **简化部署**：只需要一个固件镜像

**如果运行时加载**：
- ❌ 需要文件系统支持
- ❌ 需要存储设备驱动
- ❌ 需要处理文件不存在的情况

### 4. 防回滚：与固件版本绑定

**编译到固件中**：
- ✅ **版本绑定**：ROTPK 与固件版本绑定，更新固件时可以更新 ROTPK
- ✅ **防回滚**：旧版本的固件无法使用新的 ROTPK

---

## 实现机制

### 1. 生成 ROTPK Hash 二进制文件

**platform.mk 中的生成规则**（以 SynQuacer 平台为例）：

```makefile
# plat/socionext/synquacer/platform.mk 第 88-91 行
ROT_KEY = $(BUILD_PLAT)/rot_key.pem
ROTPK_HASH = $(BUILD_PLAT)/rotpk_sha256.bin

$(ROTPK_HASH): $(ROT_KEY) | $$(@D)/
	$(s)echo "  OPENSSL $@"
	$(q)${OPENSSL_BIN_PATH}/openssl rsa -in $< -pubout -outform DER 2>/dev/null |\
	${OPENSSL_BIN_PATH}/openssl dgst -sha256 -binary > $@ 2>/dev/null
```

**生成过程**：
1. 从私钥提取公钥（DER 格式）
2. 计算公钥的 SHA256 hash
3. 保存为二进制文件 `rotpk_sha256.bin`

### 2. 汇编代码嵌入二进制文件

**sq_rotpk.S 第 7-16 行**：

```assembly
.global sq_rotpk_hash
.global sq_rotpk_hash_end
.section .rodata.sq_rotpk_hash, "a"
sq_rotpk_hash:
	/* DER header */
	.byte 0x30, 0x31, 0x30, 0x0D, 0x06, 0x09, 0x60, 0x86, 0x48
	.byte 0x01, 0x65, 0x03, 0x04, 0x02, 0x01, 0x05, 0x00, 0x04, 0x20
	/* SHA256 hash */
	.incbin ROTPK_HASH          # ← 嵌入二进制文件
sq_rotpk_hash_end:
```

**关键指令**：
- `.incbin ROTPK_HASH`：将 `ROTPK_HASH` 指定的二进制文件内容直接嵌入到汇编代码中
- `.section .rodata.sq_rotpk_hash, "a"`：将数据放在只读数据段
- `sq_rotpk_hash` 和 `sq_rotpk_hash_end`：定义符号，用于在 C 代码中访问

### 3. C 代码中使用嵌入的公钥

**rpi3_trusted_boot.c 第 9-18 行**：

```c
extern char rpi3_rotpk_hash[], rpi3_rotpk_hash_end[];

int plat_get_rotpk_info(void *cookie, void **key_ptr, unsigned int *key_len,
			unsigned int *flags)
{
	*key_ptr = rpi3_rotpk_hash;                    // ← 指向嵌入的公钥数据
	*key_len = rpi3_rotpk_hash_end - rpi3_rotpk_hash;  // ← 计算长度
	*flags = ROTPK_IS_HASH;                        // ← 标记为 hash 格式

	return 0;
}
```

**工作流程**：
1. 汇编代码定义符号 `rpi3_rotpk_hash` 和 `rpi3_rotpk_hash_end`
2. C 代码通过 `extern` 声明这些符号
3. `plat_get_rotpk_info()` 返回嵌入数据的指针和长度
4. 认证模块使用这些数据验证证书

---

## 完整流程示例

### 示例：SynQuacer 平台

```
1. 编译时生成 ROTPK Hash
   ↓
   openssl rsa -in rot_key.pem -pubout -outform DER | \
   openssl dgst -sha256 -binary > rotpk_sha256.bin
   ↓
2. 汇编代码嵌入二进制文件
   ↓
   sq_rotpk.S:
   .incbin ROTPK_HASH  # ROTPK_HASH = build/.../rotpk_sha256.bin
   ↓
3. 编译为对象文件
   ↓
   sq_rotpk.o 包含嵌入的 hash 数据
   ↓
4. 链接到固件
   ↓
   bl2.elf 包含 ROTPK hash 数据
   ↓
5. 运行时使用
   ↓
   plat_get_rotpk_info() 返回嵌入数据的指针
```

---

## 两种存储方式对比

### 方式 1：编译到固件中（当前方式）

**优点**：
- ✅ **安全性高**：编译时确定，难以篡改
- ✅ **性能好**：零延迟，无 I/O 开销
- ✅ **设计简单**：无需外部存储
- ✅ **防回滚**：与固件版本绑定

**缺点**：
- ❌ **更新困难**：需要重新编译固件才能更新 ROTPK
- ❌ **灵活性低**：不同设备需要使用不同的固件镜像

**适用场景**：
- 生产环境，ROTPK 固定
- 对安全性要求极高的场景
- 不需要频繁更新 ROTPK 的场景

### 方式 2：运行时从外部存储加载

**优点**：
- ✅ **灵活性高**：可以更新 ROTPK 而无需重新编译
- ✅ **统一镜像**：同一固件可以用于不同设备

**缺点**：
- ❌ **安全性低**：可能被恶意替换
- ❌ **性能差**：需要 I/O 操作
- ❌ **设计复杂**：需要文件系统、存储驱动
- ❌ **依赖外部**：依赖存储设备的可靠性

**适用场景**：
- 开发/测试环境
- 需要灵活更新 ROTPK 的场景
- 有安全存储机制的场景（如 TPM、HSM）

---

## 实际代码示例

### 1. ARM 通用实现（arm_dev_rotpk.S）

**plat/arm/board/common/rotpk/arm_dev_rotpk.S 第 44-47 行**：

```assembly
#ifdef ARM_ROTPK
	.incbin ARM_ROTPK              # ← 嵌入 ROTPK 二进制文件
arm_rotpk_hash_end:
#endif
```

**支持两种模式**：
- **Hash 模式**（`ARM_ROTPK_IS_HASH == 1`）：存储 ROTPK 的 hash
- **完整公钥模式**（`ARM_ROTPK_IS_HASH == 0`）：存储完整的公钥 DER

### 2. QEMU 平台实现

**plat/qemu/common/qemu_rotpk.S**：

```assembly
.global qemu_rotpk_hash
.global qemu_rotpk_hash_end
qemu_rotpk_hash:
	/* DER header for SHA256 hash */
	.byte 0x30, 0x31, 0x30, 0x0D, 0x06, 0x09, 0x60, 0x86, 0x48
	.byte 0x01, 0x65, 0x03, 0x04, 0x02, 0x01, 0x05, 0x00, 0x04, 0x20
	/* SHA256 hash (32 bytes) */
	.incbin ROTPK_HASH              # ← 嵌入 hash 二进制文件
qemu_rotpk_hash_end:
```

### 3. Makefile 配置

**plat/qemu/qemu/platform.mk 第 58 行**：

```makefile
BL1_SOURCES += $(PLAT_QEMU_COMMON_PATH)/qemu_rotpk.S
```

**编译依赖**：

```makefile
# 定义 ROTPK_HASH 宏，指向二进制文件路径
$(eval $(call add_define_val,ROTPK_HASH,'"$(ROTPK_HASH)"'))

# 对象文件依赖于二进制文件
$(BUILD_PLAT)/bl2/qemu_rotpk.o: $(ROTPK_HASH)
```

---

## 为什么使用 Hash 而不是完整公钥？

### 1. 存储空间

| 类型 | 大小 | 说明 |
|------|------|------|
| **RSA 2048 公钥（DER）** | ~294 字节 | 完整的公钥 |
| **RSA 2048 公钥 Hash** | 32 字节（SHA256） | 公钥的 hash |
| **ECDSA P-256 公钥（DER）** | ~91 字节 | 完整的公钥 |
| **ECDSA P-256 公钥 Hash** | 32 字节（SHA256） | 公钥的 hash |

**使用 Hash 的优势**：
- ✅ **节省空间**：Hash 比完整公钥小得多
- ✅ **固定大小**：SHA256 固定 32 字节，便于处理

### 2. 安全性

**Hash 方式**：
- ✅ **隐私保护**：不暴露完整的公钥结构
- ✅ **一致性**：Hash 格式统一，便于验证

**完整公钥方式**：
- ✅ **直接验证**：可以直接比较公钥
- ❌ **暴露信息**：暴露公钥的完整结构

### 3. 验证流程

**使用 Hash 验证**（auth_mod.c 第 251-273 行）：

```c
if ((flags & ROTPK_IS_HASH) != 0U) {
    /* 从证书提取公钥 */
    rc = crypto_mod_convert_pk(pk_ptr, pk_len, &cnv_pk_ptr, &cnv_pk_len);
    
    /* 计算公钥的 hash */
    /* 与平台存储的 hash 比较 */
    rc = crypto_mod_verify_hash(cnv_pk_ptr, cnv_pk_len,
                                pk_plat_ptr, pk_plat_len);
}
```

**使用完整公钥验证**（auth_mod.c 第 274-280 行）：

```c
else {
    /* 直接比较公钥 */
    if ((pk_len != pk_plat_len) ||
        (memcmp(pk_plat_ptr, pk_ptr, pk_len) != 0)) {
        ERROR("plat and cert ROTPK len mismatch\n");
        return -1;
    }
}
```

---

## 总结

### 为什么编译为二进制文件？

1. **安全性**：
   - ROTPK 是信任根，必须在编译时确定
   - 编译到固件中，难以被篡改
   - 与固件版本绑定，防止回滚攻击

2. **性能**：
   - 零延迟访问，无需 I/O 操作
   - 启动时间可预测
   - 无外部存储依赖

3. **简化设计**：
   - 自包含的固件镜像
   - 无需文件系统支持
   - 简化部署流程

4. **防篡改**：
   - 成为固件的一部分
   - 与固件一起签名和验证
   - 难以被外部修改

### 实现方式

1. **生成阶段**：使用 OpenSSL 从私钥提取公钥并计算 hash，保存为 `.bin` 文件
2. **编译阶段**：使用汇编的 `.incbin` 指令将二进制文件嵌入到固件中
3. **运行时**：通过 `plat_get_rotpk_info()` 返回嵌入数据的指针

### 关键代码位置

- **生成规则**：`plat/*/platform.mk`（如 `synquacer/platform.mk` 第 88-91 行）
- **汇编嵌入**：`plat/*/*rotpk.S`（如 `sq_rotpk.S` 第 15 行）
- **C 代码使用**：`plat/*/*trusted_boot.c`（如 `rpi3_trusted_boot.c` 第 11-18 行）
- **认证使用**：`drivers/auth/auth_mod.c` 第 220-280 行

---

**参考文档**：
- TF-A 平台移植指南：`docs/plat/porting-guide.rst`
- 认证框架设计：`docs/design/auth-framework.rst`
- 平台实现示例：`plat/socionext/synquacer/`, `plat/qemu/common/`

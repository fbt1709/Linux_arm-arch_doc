# 验证时如何获取公钥

## 问题

如果证书是自签名的（使用自己的私钥签名），那么在验证时，验证者如何获取公钥来验证签名？

---

## 答案：两种方式获取公钥

### 方式 1：根证书 - 从平台获取 ROTPK

**适用场景**：根证书（`parent == NULL`）

**代码位置**：`auth_mod.c` 第 215-292 行

```c
if (img_desc->parent == NULL) {
    // ← 根证书：从平台获取 ROTPK
    rc = plat_get_rotpk_info(param->pk->cookie, &pk_plat_ptr,
                             &pk_plat_len, &flags);
    // pk_plat_ptr → 平台存储的 ROTPK（ROT_KEY 的公钥）
    
    // 从证书中提取 Subject Public Key
    rc = img_parser_get_auth_param(img_desc->img_type,
                                   param->pk, img, img_len,
                                   &pk_ptr, &pk_len);
    // pk_ptr → 证书的 Subject Public Key（也是 ROTPK）
    
    // 验证证书的 Subject PK 是否与平台 ROTPK 匹配
    if (memcmp(pk_plat_ptr, pk_ptr, pk_len) != 0) {
        return -1;  // ← 不匹配，验证失败
    }
    
    // 使用 ROTPK 验证签名
    crypto_mod_verify_signature(..., pk_ptr, pk_len);
    // pk_ptr = ROTPK（从证书提取，已验证与平台 ROTPK 匹配）
}
```

**关键点**：
- ✅ **ROTPK 存储在平台**：通过 `plat_get_rotpk_info()` 获取
- ✅ **ROTPK 嵌入在证书中**：作为证书的 Subject Public Key
- ✅ **验证匹配**：确保证书中的 ROTPK 与平台存储的 ROTPK 一致
- ✅ **使用 ROTPK 验证签名**：使用证书中的 ROTPK（已验证）验证签名

### 方式 2：非根证书 - 从父证书扩展中提取公钥

**适用场景**：非根证书（`parent != NULL`）

**代码位置**：`auth_mod.c` 第 207-214 行

```c
if (img_desc->parent != NULL) {
    // ← 非根证书：从父证书的扩展中获取公钥
    rc = auth_get_param(param->pk, img_desc->parent,
                        &pk_ptr, &pk_len);
    // pk_ptr → 从父证书的 authenticated_data 中提取的公钥
}
```

**关键点**：
- ✅ **公钥存储在父证书的扩展中**：父证书验证后，提取公钥存储到 `authenticated_data`
- ✅ **父证书已验证**：在验证当前证书之前，父证书已经被验证
- ✅ **使用父证书的公钥验证**：使用从父证书提取的公钥验证当前证书的签名

---

## 完整流程示例

### 示例 1：验证根证书（FWU_CERT）

**证书定义**（`tbbr_cot_bl1.c` 第 47-85 行）：

```c
static const auth_img_desc_t fwu_cert = {
    .img_id = FWU_CERT_ID,
    .parent = NULL,  // ← 根证书
    .img_auth_methods = {
        [0] = {
            .type = AUTH_METHOD_SIG,
            .param.sig = {
                .pk = &subject_pk,  // ← 使用 Subject PK（ROTPK）
                ...
            }
        }
    }
};
```

**验证流程**：

```
1. 加载 FWU_CERT 到内存
   ↓
2. 判断：parent == NULL → 根证书
   ↓
3. 从平台获取 ROTPK
   plat_get_rotpk_info(..., &pk_plat_ptr, ...)
   → pk_plat_ptr = 平台存储的 ROTPK（hash 或完整公钥）
   ↓
4. 从证书提取 Subject Public Key
   img_parser_get_auth_param(..., AUTH_PARAM_PUB_KEY, ...)
   → pk_ptr = 证书的 Subject PK（ROTPK）
   ↓
5. 验证匹配
   if (ROTPK_IS_HASH) {
       hash(cert_subject_pk) == platform_rotpk_hash
   } else {
       cert_subject_pk == platform_rotpk
   }
   → 如果匹配，继续
   → 如果不匹配，验证失败 ❌
   ↓
6. 提取被签名的数据（TBSCertificate）
   → data_ptr = tbs.p
   ↓
7. 提取签名值
   → sig_ptr = signature.p
   ↓
8. 使用 ROTPK 验证签名
   crypto_mod_verify_signature(data_ptr, sig_ptr, pk_ptr)
   → 使用证书中的 ROTPK（已验证与平台匹配）验证签名
   → 如果验证成功，继续
   → 如果验证失败，启动失败 ❌
```

**关键**：
- ✅ **ROTPK 来源**：平台存储（通过 `plat_get_rotpk_info()`）
- ✅ **ROTPK 验证**：证书中的 ROTPK 必须与平台 ROTPK 匹配
- ✅ **签名验证**：使用证书中的 ROTPK 验证签名

---

### 示例 2：验证非根证书（SOC_FW_KEY_CERT）

**证书定义**（`tbbr_cot_bl2.c` 第 229-260 行）：

```c
static const auth_img_desc_t soc_fw_key_cert = {
    .img_id = SOC_FW_KEY_CERT_ID,
    .parent = &trusted_key_cert,  // ← 有父证书
    .img_auth_methods = {
        [0] = {
            .type = AUTH_METHOD_SIG,
            .param.sig = {
                .pk = &trusted_world_pk,  // ← 从父证书获取公钥
                ...
            }
        }
    }
};
```

**父证书定义**（`tbbr_cot_bl2.c` 第 60-90 行）：

```c
static const auth_img_desc_t trusted_key_cert = {
    .img_id = TRUSTED_KEY_CERT_ID,
    .parent = NULL,  // ← 根证书
    .authenticated_data = {
        [0] = {
            .type_desc = &trusted_world_pk,  // ← Trusted World PK 扩展
            .data = {
                .ptr = (void *)trusted_world_pk_buf,  // ← 存储提取的公钥
                .len = (unsigned int)PK_DER_LEN
            }
        }
    }
};
```

**验证流程**：

```
1. 先验证父证书（TRUSTED_KEY_CERT）
   ↓
   1.1 从平台获取 ROTPK
       plat_get_rotpk_info(...)
   ↓
   1.2 验证父证书签名（使用平台 ROTPK）
   ↓
   1.3 提取 Trusted World PK（从父证书扩展）
       img_parser_get_auth_param(..., TRUSTED_WORLD_PK_OID, ...)
       → 提取公钥
   ↓
   1.4 存储到 authenticated_data
       trusted_world_pk_buf = 提取的公钥
   ↓
2. 验证当前证书（SOC_FW_KEY_CERT）
   ↓
   2.1 判断：parent != NULL → 非根证书
   ↓
   2.2 从父证书获取公钥
       auth_get_param(&trusted_world_pk, &trusted_key_cert, ...)
       → pk_ptr = trusted_world_pk_buf（从父证书扩展中提取的公钥）
   ↓
   2.3 提取被签名的数据
       → data_ptr = TBSCertificate
   ↓
   2.4 提取签名值
       → sig_ptr = signature
   ↓
   2.5 使用 Trusted World PK 验证签名
       crypto_mod_verify_signature(data_ptr, sig_ptr, pk_ptr)
       → 使用从父证书提取的公钥验证签名
```

**关键**：
- ✅ **公钥来源**：父证书的扩展（`TRUSTED_WORLD_PK_EXT`）
- ✅ **父证书已验证**：在验证当前证书之前，父证书已经验证
- ✅ **公钥已提取**：父证书验证后，公钥已存储到 `authenticated_data`

---

## 公钥的获取路径

### 路径 1：根证书 → 平台 ROTPK

```
平台存储（硬件/固件）
    ↓ plat_get_rotpk_info()
ROTPK（ROT_KEY 的公钥）
    ↓ 验证匹配
证书的 Subject Public Key（ROTPK）
    ↓ 验证签名
证书签名验证成功
```

### 路径 2：非根证书 → 父证书扩展

```
父证书（已验证）
    ↓ 提取扩展
父证书的扩展（如 TRUSTED_WORLD_PK_EXT）
    ↓ 提取公钥
authenticated_data（如 trusted_world_pk_buf）
    ↓ auth_get_param()
当前证书验证使用的公钥
    ↓ 验证签名
当前证书签名验证成功
```

---

## 关键代码解析

### 1. 根证书的公钥获取（`auth_mod.c` 第 220-238 行）

```c
// 从平台获取 ROTPK
rc = plat_get_rotpk_info(param->pk->cookie, &pk_plat_ptr,
                         &pk_plat_len, &flags);
// pk_plat_ptr → 平台存储的 ROTPK

// 从证书提取 Subject Public Key
rc = img_parser_get_auth_param(img_desc->img_type,
                               param->pk, img, img_len,
                               &pk_ptr, &pk_len);
// pk_ptr → 证书的 Subject PK（ROTPK）

// 验证匹配
if (memcmp(pk_plat_ptr, pk_ptr, pk_len) != 0) {
    return -1;  // ← 不匹配，验证失败
}

// 使用证书中的 ROTPK 验证签名
crypto_mod_verify_signature(..., pk_ptr, pk_len);
// pk_ptr = ROTPK（已验证与平台匹配）
```

### 2. 非根证书的公钥获取（`auth_mod.c` 第 207-214 行）

```c
// 从父证书的 authenticated_data 中获取公钥
rc = auth_get_param(param->pk, img_desc->parent,
                    &pk_ptr, &pk_len);
// pk_ptr → 从父证书扩展中提取的公钥（已存储到 authenticated_data）

// 使用父证书的公钥验证签名
crypto_mod_verify_signature(..., pk_ptr, pk_len);
```

### 3. 父证书公钥的提取和存储（`auth_mod.c` 第 520-540 行）

```c
int auth_mod_verify_img(...)
{
    // 验证证书签名
    rc = auth_signature(...);
    
    // 如果验证成功，提取 authenticated_data
    if (img_desc->authenticated_data != NULL) {
        for (i = 0; i < COT_MAX_VERIFIED_PARAMS; i++) {
            // 从证书扩展中提取数据（如公钥）
            rc = img_parser_get_auth_param(img_desc->img_type,
                                           img_desc->authenticated_data[i].type_desc,
                                           img_ptr, img_len,
                                           &param_ptr, &param_len);
            
            // 存储到 authenticated_data 缓冲区
            memcpy((void *)img_desc->authenticated_data[i].data.ptr,
                   (void *)param_ptr, param_len);
            // ← 例如：trusted_world_pk_buf = 提取的公钥
        }
    }
}
```

---

## 完整信任链的公钥传递

```
1. 平台 ROTPK（硬件/固件存储）
   ↓ plat_get_rotpk_info()
2. TRUSTED_KEY_CERT（根证书）
   ├─ Subject PK = ROTPK（从证书提取）
   ├─ 验证：cert_subject_pk == platform_rotpk ✅
   ├─ 签名验证：使用 ROTPK 验证签名 ✅
   └─ 提取扩展：TRUSTED_WORLD_PK_EXT
       → 存储到 trusted_world_pk_buf
   ↓ auth_get_param()
3. SOC_FW_KEY_CERT（非根证书）
   ├─ 公钥来源：trusted_world_pk_buf（从父证书扩展提取）
   ├─ 签名验证：使用 Trusted World PK 验证签名 ✅
   └─ 提取扩展：SOC_FW_CONTENT_CERT_PK_EXT
       → 存储到 content_pk_buf
   ↓ auth_get_param()
4. SOC_FW_CONTENT_CERT（非根证书）
   ├─ 公钥来源：content_pk_buf（从父证书扩展提取）
   └─ 签名验证：使用 Content Cert PK 验证签名 ✅
   ↓
5. BL31 镜像
   └─ Hash 验证：使用 Content Cert 中的 hash 验证 ✅
```

---

## 总结

### 公钥获取的两种方式

| 证书类型 | 公钥来源 | 获取方式 | 代码位置 |
|---------|---------|---------|---------|
| **根证书**<br>（parent == NULL） | 平台 ROTPK | `plat_get_rotpk_info()` | `auth_mod.c` 第 220 行 |
| **非根证书**<br>（parent != NULL） | 父证书扩展 | `auth_get_param()` | `auth_mod.c` 第 208 行 |

### 关键点

1. **根证书**：
   - ✅ ROTPK 存储在平台（硬件/固件）
   - ✅ 证书的 Subject PK = ROTPK
   - ✅ 验证时：确保证书中的 ROTPK 与平台 ROTPK 匹配
   - ✅ 使用证书中的 ROTPK（已验证）验证签名

2. **非根证书**：
   - ✅ 公钥存储在父证书的扩展中
   - ✅ 父证书验证后，提取公钥存储到 `authenticated_data`
   - ✅ 验证时：从父证书的 `authenticated_data` 获取公钥
   - ✅ 使用父证书的公钥验证当前证书的签名

### 为什么这样设计？

- ✅ **ROTPK 是信任根**：平台存储的 ROTPK 是最终的信任锚点
- ✅ **公钥通过证书传递**：父证书的扩展中存储子证书的公钥
- ✅ **形成信任链**：ROTPK → 根证书 → 子证书 → 固件镜像

---

**参考代码位置**：
- 根证书公钥获取：`drivers/auth/auth_mod.c` 第 220-238 行
- 非根证书公钥获取：`drivers/auth/auth_mod.c` 第 207-214 行
- 公钥提取和存储：`drivers/auth/auth_mod.c` 第 520-540 行
- 平台 ROTPK：`plat/*/trusted_boot.c`（平台特定实现）

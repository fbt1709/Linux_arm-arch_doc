# 证书签名验证过程详解

## 概述

TF-A 中的证书验签过程是对证书的**数字签名（Digital Signature）**进行验证，确保证书的完整性和真实性。验证过程包括从证书中提取签名、被签名的数据、签名算法和公钥，然后使用密码学库进行验证。

---

## X.509 证书结构

X.509 证书的结构如下：

```
Certificate ::= SEQUENCE {
    tbsCertificate       TBSCertificate,      ← 被签名的数据
    signatureAlgorithm   AlgorithmIdentifier, ← 签名算法
    signatureValue       BIT STRING           ← 签名值
}

TBSCertificate ::= SEQUENCE {
    version              [0] EXPLICIT Version DEFAULT v1,
    serialNumber         CertificateSerialNumber,
    signature            AlgorithmIdentifier,
    issuer               Name,
    validity             Validity,
    subject              Name,
    subjectPublicKeyInfo SubjectPublicKeyInfo,
    issuerUniqueID       [1] IMPLICIT UniqueIdentifier OPTIONAL,
    subjectUniqueID      [2] IMPLICIT UniqueIdentifier OPTIONAL,
    extensions           [3] EXPLICIT Extensions OPTIONAL
}
```

**关键点**：
- **`tbsCertificate`**：To-Be-Signed Certificate，证书的主体部分，是**被签名的数据**
- **`signatureValue`**：数字签名值，是对 `tbsCertificate` 的签名
- **`signatureAlgorithm`**：签名算法（如 RSA-SHA256, ECDSA-SHA256）

---

## 证书验签流程

### 完整流程图

```
1. 加载证书到内存
   ↓
2. 解析证书结构（check_integrity）
   ↓
3. 提取验证所需参数（auth_signature）
   ├─ 提取被签名的数据（TBSCertificate）
   ├─ 提取签名值（signatureValue）
   ├─ 提取签名算法（signatureAlgorithm）
   └─ 获取公钥（从父证书或平台）
   ↓
4. 使用公钥验证签名（crypto_mod_verify_signature）
   ├─ 计算 TBSCertificate 的 hash
   └─ 验证签名是否匹配
   ↓
5. 验证成功/失败
```

---

## 详细步骤

### 步骤 1：证书完整性检查

**函数**：`img_parser_check_integrity()` (`mbedtls_x509_parser.c` 第 439-447 行)

```c
static int check_integrity(void *img, unsigned int img_len)
{
    int rc = cert_parse(img, img_len);  // ← 解析证书结构
    
    if (rc != IMG_PARSER_OK)
        clear_temp_vars();
    
    return rc;
}
```

**`cert_parse()` 函数**（`mbedtls_x509_parser.c` 第 232-239 行）：

```c
// 解析 TBSCertificate（被签名的数据）
tbs.p = p;
ret = mbedtls_asn1_get_tag(&p, end, &len, MBEDTLS_ASN1_CONSTRUCTED |
                           MBEDTLS_ASN1_SEQUENCE);
tbs.len = end - tbs.p;  // ← 保存 TBSCertificate 的位置和长度

// 解析签名算法
sig_alg1.p = p;
// ... 解析 AlgorithmIdentifier
sig_alg1.len = (p + len) - sig_alg1.p;

// 解析签名值
signature.p = p;
ret = mbedtls_asn1_get_bitstring_null(&p, end, &len);
signature.len = end - signature.p;  // ← 保存签名值的位置和长度
```

**结果**：
- `tbs`：TBSCertificate 的位置和长度（被签名的数据）
- `signature`：签名值的位置和长度
- `sig_alg`：签名算法的位置和长度
- `pk`：Subject Public Key 的位置和长度

---

### 步骤 2：调用签名验证函数

**函数**：`auth_mod_verify_img()` (`auth_mod.c` 第 459-585 行)

```c
int auth_mod_verify_img(unsigned int img_id, void *img_ptr, unsigned int img_len)
{
    // 1. 获取证书描述符
    img_desc = FCONF_GET_PROPERTY(tbbr, cot, img_id);
    
    // 2. 检查证书完整性
    rc = img_parser_check_integrity(img_desc->img_type, img_ptr, img_len);
    
    // 3. 遍历认证方法
    for (i = 0; i < AUTH_METHOD_NUM; i++) {
        auth_method = &img_desc->img_auth_methods[i];
        switch (auth_method->type) {
        case AUTH_METHOD_SIG:
            // ← 调用签名验证
            rc = auth_signature(&auth_method->param.sig,
                               img_desc, img_ptr, img_len);
            break;
        }
    }
}
```

---

### 步骤 3：提取验证参数

**函数**：`auth_signature()` (`auth_mod.c` 第 156-305 行)

#### 3.1 提取被签名的数据（TBSCertificate）

```c
// 从证书中提取 TBSCertificate（被签名的数据）
rc = img_parser_get_auth_param(img_desc->img_type, param->data,
        img, img_len, &data_ptr, &data_len);
// data_ptr → 指向 tbs.p（TBSCertificate 的起始位置）
// data_len → tbs.len（TBSCertificate 的长度）
```

**实现**（`mbedtls_x509_parser.c` 第 469-473 行）：

```c
case AUTH_PARAM_RAW_DATA:
    /* Data to be signed */
    *param = (void *)tbs.p;        // ← 指向 TBSCertificate
    *param_len = (unsigned int)tbs.len;  // ← TBSCertificate 长度
    break;
```

#### 3.2 提取签名值

```c
// 从证书中提取签名值
rc = img_parser_get_auth_param(img_desc->img_type, param->sig,
        img, img_len, &sig_ptr, &sig_len);
// sig_ptr → 指向 signature.p（签名值的起始位置）
// sig_len → signature.len（签名值的长度）
```

**实现**（`mbedtls_x509_parser.c` 第 494-498 行）：

```c
case AUTH_PARAM_SIG:
    /* Get the certificate signature */
    *param = (void *)signature.p;   // ← 指向签名值
    *param_len = (unsigned int)signature.len;  // ← 签名值长度
    break;
```

#### 3.3 提取签名算法

```c
// 从证书中提取签名算法
rc = img_parser_get_auth_param(img_desc->img_type, param->alg,
        img, img_len, &sig_alg_ptr, &sig_alg_len);
// sig_alg_ptr → 指向 sig_alg.p（签名算法的起始位置）
```

**实现**（`mbedtls_x509_parser.c` 第 489-493 行）：

```c
case AUTH_PARAM_SIG_ALG:
    /* Get the certificate signature algorithm */
    *param = (void *)sig_alg.p;    // ← 指向签名算法
    *param_len = (unsigned int)sig_alg.len;
    break;
```

#### 3.4 获取公钥

**两种情况**：

**情况 A：有父证书**（非根证书）

```c
if (img_desc->parent != NULL) {
    // 从父证书的 authenticated_data 中获取公钥
    rc = auth_get_param(param->pk, img_desc->parent,
            &pk_ptr, &pk_len);
    // pk_ptr → 指向父证书扩展中提取的公钥
}
```

**情况 B：根证书**（使用 ROTPK）

```c
else {
    // 1. 从平台获取 ROTPK
    rc = plat_get_rotpk_info(param->pk->cookie, &pk_plat_ptr,
                             &pk_plat_len, &flags);
    
    // 2. 从证书中提取 Subject Public Key
    rc = img_parser_get_auth_param(img_desc->img_type,
                                   param->pk, img, img_len,
                                   &pk_ptr, &pk_len);
    
    // 3. 验证证书的 Subject PK 是否与平台 ROTPK 匹配
    if ((flags & ROTPK_IS_HASH) != 0U) {
        // 比较 hash
        rc = crypto_mod_verify_hash(cnv_pk_ptr, cnv_pk_len,
                                    pk_plat_ptr, pk_plat_len);
    } else {
        // 直接比较
        if (memcmp(pk_plat_ptr, pk_ptr, pk_len) != 0) {
            return -1;  // ← 不匹配，验证失败
        }
    }
}
```

---

### 步骤 4：执行签名验证

**函数**：`crypto_mod_verify_signature()` (`crypto_mod.c` 第 79-93 行)

```c
int crypto_mod_verify_signature(void *data_ptr, unsigned int data_len,
                                void *sig_ptr, unsigned int sig_len,
                                void *sig_alg, unsigned int sig_alg_len,
                                void *pk_ptr, unsigned int pk_len)
{
    // 调用密码学库的验证函数
    return crypto_lib_desc.verify_signature(data_ptr, data_len,
                                            sig_ptr, sig_len,
                                            sig_alg, sig_alg_len,
                                            pk_ptr, pk_len);
}
```

**实际实现**：`verify_signature()` (`mbedtls_psa_crypto.c` 第 238-343 行 或 `mbedtls_crypto.c` 第 86-167 行)

#### 4.1 解析签名算法

```c
// 解析签名算法 OID
p = (unsigned char *)sig_alg;
end = (unsigned char *)(p + sig_alg_len);
rc = mbedtls_asn1_get_alg(&p, end, &sig_oid, &sig_params);

// 获取实际的签名算法（MD + PK）
rc = mbedtls_x509_get_sig_alg(&sig_oid, &sig_params, 
                               &md_alg, &pk_alg, &sig_opts);
// md_alg → 哈希算法（如 MBEDTLS_MD_SHA256）
// pk_alg → 公钥算法（如 MBEDTLS_PK_RSA, MBEDTLS_PK_ECDSA）
```

#### 4.2 解析公钥

```c
// 解析公钥
mbedtls_pk_init(&pk);
p = (unsigned char *)pk_ptr;
end = (unsigned char *)(p + pk_len);
rc = mbedtls_pk_parse_subpubkey(&p, end, &pk);
// pk → mbedtls_pk_context 对象，包含公钥信息
```

#### 4.3 提取签名值

```c
// 从 BIT STRING 中提取签名值
p = (unsigned char *)sig_ptr;
end = (unsigned char *)(p + sig_len);
signature.tag = *p;
rc = mbedtls_asn1_get_bitstring_null(&p, end, &signature.len);
signature.p = p;  // ← 指向实际的签名值
```

**注意**：对于 ECDSA，可能需要将 DER 格式转换为原始格式：

```c
if (PSA_ALG_IS_ECDSA(psa_alg)) {
    // 将 DER ASN.1 签名转换为原始格式
    rc = mbedtls_ecdsa_der_to_raw(key_bits, p, local_sig_len,
                                  reformatted_sig, ECDSA_SIG_BUFFER_SIZE,
                                  &local_sig_len);
    local_sig_ptr = reformatted_sig;
}
```

#### 4.4 计算被签名数据的 Hash

**方法 1**：使用 mbedTLS（`mbedtls_crypto.c` 第 137-148 行）

```c
// 计算 TBSCertificate 的 hash
md_info = mbedtls_md_info_from_type(md_alg);  // 例如 SHA256
p = (unsigned char *)data_ptr;
rc = mbedtls_md(md_info, p, data_len, hash);
// hash → 计算出的 hash 值
```

**方法 2**：使用 PSA Crypto（`mbedtls_psa_crypto.c` 第 330-332 行）

```c
// 直接验证签名（PSA 内部会计算 hash）
psa_status = psa_verify_message(psa_key_id, psa_alg,
                                data_ptr, data_len,
                                local_sig_ptr, local_sig_len);
```

#### 4.5 验证签名

**方法 1**：使用 mbedTLS（`mbedtls_crypto.c` 第 150-153 行）

```c
// 使用公钥验证签名
rc = mbedtls_pk_verify_ext(pk_alg, sig_opts, &pk, md_alg, hash,
        mbedtls_md_get_size(md_info),  // hash 长度
        signature.p, signature.len);   // 签名值
```

**方法 2**：使用 PSA Crypto（`mbedtls_psa_crypto.c` 第 330-332 行）

```c
// PSA 内部会：
// 1. 计算 data_ptr 的 hash（使用 psa_alg 指定的算法）
// 2. 使用公钥验证签名
psa_status = psa_verify_message(psa_key_id, psa_alg,
                                data_ptr, data_len,
                                local_sig_ptr, local_sig_len);
```

**验证原理**：
```
签名生成时（cert_create）：
    hash = SHA256(TBSCertificate)
    signature = RSA_PrivateKey_Encrypt(hash)  // 或 ECDSA_Sign(hash)

签名验证时（TF-A）：
    hash' = SHA256(TBSCertificate)
    hash'' = RSA_PublicKey_Decrypt(signature)  // 或 ECDSA_Verify(signature)
    
    如果 hash' == hash''，则验证成功 ✅
```

---

## 完整代码流程

### 示例：验证 SOC_FW_KEY_CERT

**证书描述符**（`tbbr_cot_bl2.c` 第 229-260 行）：

```c
static const auth_img_desc_t soc_fw_key_cert = {
    .img_id = SOC_FW_KEY_CERT_ID,
    .img_type = IMG_CERT,
    .parent = &trusted_key_cert,  // ← 父证书
    .img_auth_methods = {
        [0] = {
            .type = AUTH_METHOD_SIG,
            .param.sig = {
                .pk = &trusted_world_pk,  // ← 从父证书获取公钥
                .sig = &sig,              // ← 提取签名值
                .alg = &sig_alg,          // ← 提取签名算法
                .data = &raw_data         // ← 提取 TBSCertificate
            }
        }
    }
};
```

**验证流程**：

```c
1. auth_mod_verify_img(SOC_FW_KEY_CERT_ID, cert_ptr, cert_len)
   ↓
2. img_parser_check_integrity(IMG_CERT, cert_ptr, cert_len)
   → 解析证书，提取 tbs, signature, sig_alg, pk
   ↓
3. auth_signature(&param.sig, img_desc, cert_ptr, cert_len)
   ↓
   3.1 提取被签名的数据
       img_parser_get_auth_param(..., AUTH_PARAM_RAW_DATA, ...)
       → data_ptr = tbs.p, data_len = tbs.len
   ↓
   3.2 提取签名值
       img_parser_get_auth_param(..., AUTH_PARAM_SIG, ...)
       → sig_ptr = signature.p, sig_len = signature.len
   ↓
   3.3 提取签名算法
       img_parser_get_auth_param(..., AUTH_PARAM_SIG_ALG, ...)
       → sig_alg_ptr = sig_alg.p, sig_alg_len = sig_alg.len
   ↓
   3.4 获取公钥（从父证书）
       auth_get_param(&trusted_world_pk, &trusted_key_cert, ...)
       → pk_ptr = trusted_world_pk_buf（从父证书扩展中提取）
   ↓
4. crypto_mod_verify_signature(data_ptr, data_len,
                                sig_ptr, sig_len,
                                sig_alg_ptr, sig_alg_len,
                                pk_ptr, pk_len)
   ↓
   4.1 解析签名算法
       → md_alg = SHA256, pk_alg = RSA
   ↓
   4.2 解析公钥
       → pk = RSA 公钥对象
   ↓
   4.3 提取签名值
       → signature = 从 BIT STRING 中提取
   ↓
   4.4 计算 hash
       hash = SHA256(TBSCertificate)
   ↓
   4.5 验证签名
       mbedtls_pk_verify_ext(..., hash, signature)
       → 使用 RSA 公钥解密 signature，得到 hash'
       → 比较 hash == hash'
   ↓
5. 返回验证结果
   → 0 = 成功，非 0 = 失败
```

---

## 关键数据结构

### 1. 证书描述符中的签名参数

```c
.param.sig = {
    .pk = &trusted_world_pk,    // ← 公钥描述符（指定从哪里获取）
    .sig = &sig,                // ← 签名描述符（指定提取签名值）
    .alg = &sig_alg,            // ← 算法描述符（指定提取签名算法）
    .data = &raw_data           // ← 数据描述符（指定提取被签名的数据）
}
```

### 2. 参数类型描述符

```c
// tbbr_cot_common.c 第 41-46 行
auth_param_type_desc_t sig = AUTH_PARAM_TYPE_DESC(AUTH_PARAM_SIG, 0);
auth_param_type_desc_t sig_alg = AUTH_PARAM_TYPE_DESC(AUTH_PARAM_SIG_ALG, 0);
auth_param_type_desc_t raw_data = AUTH_PARAM_TYPE_DESC(AUTH_PARAM_RAW_DATA, 0);
```

---

## 签名验证的数学原理

### RSA 签名验证

```
签名生成（cert_create）：
    1. hash = SHA256(TBSCertificate)
    2. signature = RSA_PrivateKey_Encrypt(hash)
       signature = hash^d mod n  （d 是私钥指数）

签名验证（TF-A）：
    1. hash' = SHA256(TBSCertificate)
    2. hash'' = RSA_PublicKey_Decrypt(signature)
       hash'' = signature^e mod n  （e 是公钥指数）
    3. 如果 hash' == hash''，则验证成功
```

### ECDSA 签名验证

```
签名生成（cert_create）：
    1. hash = SHA256(TBSCertificate)
    2. (r, s) = ECDSA_Sign(hash, private_key)

签名验证（TF-A）：
    1. hash' = SHA256(TBSCertificate)
    2. result = ECDSA_Verify(hash', (r, s), public_key)
    3. 如果 result == 1，则验证成功
```

---

## 总结

### 证书验签的关键步骤

1. **提取被签名的数据**：从证书中提取 `TBSCertificate`（`tbs.p` 和 `tbs.len`）
2. **提取签名值**：从证书中提取 `signatureValue`（`signature.p` 和 `signature.len`）
3. **提取签名算法**：从证书中提取 `signatureAlgorithm`（`sig_alg.p` 和 `sig_alg.len`）
4. **获取公钥**：从父证书的扩展中提取，或从平台获取 ROTPK
5. **计算 hash**：对 `TBSCertificate` 计算 hash（如 SHA256）
6. **验证签名**：使用公钥验证签名是否与 hash 匹配

### 验证的对象

- ✅ **验证的是证书的签名**（`signatureValue`）
- ✅ **被签名的数据是 TBSCertificate**（证书的主体部分）
- ✅ **使用公钥验证**（从父证书或平台获取）

### 代码位置

- **签名验证入口**：`auth_mod.c` 第 156-305 行（`auth_signature`）
- **参数提取**：`mbedtls_x509_parser.c` 第 459-505 行（`get_auth_param`）
- **密码学验证**：`mbedtls_crypto.c` 第 86-167 行 或 `mbedtls_psa_crypto.c` 第 238-343 行（`verify_signature`）

---

**参考代码位置**：
- 签名验证：`drivers/auth/auth_mod.c` 第 156-305 行
- 证书解析：`drivers/auth/mbedtls/mbedtls_x509_parser.c`
- 密码学库：`drivers/auth/mbedtls/mbedtls_crypto.c` 或 `mbedtls_psa_crypto.c`

# EL2t和EL2h的区别详解

## 核心区别

虽然都是**EL2异常等级**，但区别在于**使用的栈指针不同**：

| 特性 | EL2t | EL2h |
|------|------|------|
| **异常等级** | EL2 | EL2 |
| **栈指针** | **SP_EL0**（用户栈） | **SP_EL2**（特权栈） |
| **模式** | Thread mode（线程模式） | Handler mode（处理程序模式） |
| **用途** | 运行用户态代码 | 运行特权代码（异常处理） |
| **M[3:0]编码** | 0x5 | 0x9 |

## 详细对比

### EL2t (EL2 with SP_EL0)

```
异常等级: EL2（虚拟化层）
栈指针: SP_EL0（用户栈指针）
模式: Thread mode（线程模式）

使用场景：
- EL2运行用户态代码
- 需要隔离的栈空间
- 较少使用
```

**特点**：
- 使用**SP_EL0**作为栈指针
- 栈空间与EL0共享（但权限不同）
- 通常用于运行非特权代码

### EL2h (EL2 with SP_EL2)

```
异常等级: EL2（虚拟化层）
栈指针: SP_EL2（特权栈指针）
模式: Handler mode（处理程序模式）

使用场景：
- EL2运行特权代码
- 异常处理程序
- 虚拟化管理程序
- 最常见的情况
```

**特点**：
- 使用**SP_EL2**作为栈指针
- 独立的特权栈空间
- 通常用于运行特权代码（如异常处理程序）

## 为什么需要两种模式？

### 1. 栈隔离

**EL2t (SP_EL0)**：
```
EL0用户程序 → 使用SP_EL0
EL2t代码   → 也使用SP_EL0（但权限不同）
```
- 共享栈空间，但通过权限隔离
- 节省内存，但安全性较低

**EL2h (SP_EL2)**：
```
EL0用户程序 → 使用SP_EL0
EL2h代码   → 使用SP_EL2（独立栈）
```
- 完全独立的栈空间
- 更高的安全性
- 更常见的使用方式

### 2. 权限级别

**EL2t**：
- 虽然运行在EL2特权级
- 但使用用户栈（SP_EL0）
- 适合运行受信任的用户代码

**EL2h**：
- 运行在EL2特权级
- 使用特权栈（SP_EL2）
- 适合运行系统级代码（异常处理、虚拟化管理）

## 实际应用场景

### EL2t的使用场景（较少）

```c
// 场景：EL2运行受信任的用户代码
// 使用SP_EL0作为栈，节省内存

// 切换到EL2t
msr spsr_el2, #(MODE_EL2 | SPSR_MODE_SP_EL0)
eret  // 返回到EL2t模式
```

### EL2h的使用场景（常见）

```c
// 场景：EL2处理异常或运行虚拟化管理程序
// 使用SP_EL2作为栈，独立且安全

// 异常发生时，硬件自动切换到EL2h
// SPSR_EL2.M[3:0] = 0x9 (EL2h)
// 使用SP_EL2作为栈指针
```

## 在你的情况中

### SPSR_EL3.M[3:0] = 0x9 (EL2h)

**含义**：
- 异常在EL2处理时，使用的是**SP_EL2**（特权栈）
- 这是**Handler mode**（处理程序模式）
- 说明EL2在处理异常或运行特权代码

**为什么不是EL2t？**
- 如果使用EL2t，M[3:0]应该是0x5
- 但实际是0x9，说明使用的是EL2h
- 这是正常的，因为异常处理通常使用Handler mode

## 栈指针切换示例

### 从EL1切换到EL2h

```
EL1执行（使用SP_EL1）
    ↓
异常发生，路由到EL2
    ↓
硬件自动：
  - 切换到EL2
  - 使用SP_EL2作为栈指针（EL2h模式）
  - 保存EL1的状态到SPSR_EL2
    ↓
EL2h执行（使用SP_EL2）
```

### 从EL1切换到EL2t（较少）

```
EL1执行（使用SP_EL1）
    ↓
软件主动切换：
  - 设置SPSR_EL2.M[3:0] = 0x5 (EL2t)
  - eret返回到EL2t
    ↓
EL2t执行（使用SP_EL0）
```

## 总结

**EL2t vs EL2h的区别**：

| 方面 | EL2t | EL2h |
|------|------|------|
| **栈指针** | SP_EL0 | SP_EL2 |
| **模式** | Thread mode | Handler mode |
| **用途** | 用户态代码 | 特权代码（异常处理） |
| **使用频率** | 较少 | 常见 |
| **安全性** | 较低（共享栈） | 较高（独立栈） |

**你的情况**：
- SPSR_EL3.M[3:0] = 0x9 (EL2h)
- 说明异常在EL2处理时使用的是**SP_EL2**（特权栈）
- 这是正常的异常处理模式
- 如果显示0x5 (EL2t)，说明使用的是SP_EL0，这种情况较少见

**关键点**：虽然都是EL2，但栈指针的选择决定了代码的特权级别和安全性。


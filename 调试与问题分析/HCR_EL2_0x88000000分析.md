# HCR_EL2 = 0x88000000 分析

## 寄存器值解析

**HCR_EL2 = 0x88000000 = 0b10001000000000000000000000000000**

## 位域分析

| 位 | 名称 | 值 | 含义 |
|---|------|-----|------|
| 0 | RW | 0 | EL2执行状态（0=AArch32, 1=AArch64） |
| 3 | FMO | 0 | FIQ路由到EL2（0=不路由，1=路由） |
| 4 | IMO | 0 | IRQ路由到EL2（0=不路由，1=路由） |
| **5** | **AMO** | **0** | **SError路由到EL2（0=不路由，1=路由）** ← **关键！** |
| 27 | TGE | 1 | EL2配置（Trap General Exceptions） |
| 31 | RW | 1 | EL2执行状态（1=AArch64） |

## 关键发现

### HCR_EL2.AMO = 0

**HCR_EL2.AMO (bit 5) = 0** 表示：
- **SError不路由到EL2**
- **应该根据SCR_EL3.EA决定路由**

### 路由判断

根据HCR_EL2.AMO = 0：
- **如果SCR_EL3.EA = 1** → SError应该路由到EL3
- **如果SCR_EL3.EA = 0** → SError路由到当前EL（EL1）

### 为什么SPSR_EL3显示EL2h？

**矛盾点**：
- HCR_EL2.AMO = 0（SError不路由到EL2）
- 但SPSR_EL3.M[3:0] = 0x9 (EL2h)（异常在EL2处理）

**可能的原因**：

#### 原因1：EL2转发异常

```
SError在EL1发生
    ↓
HCR_EL2.AMO = 0，SCR_EL3.EA = 1 → 路由到EL3
    ↓
但EL2可能拦截并转发异常
    ↓
EL2处理异常，然后转发到EL3
    ↓
SPSR_EL3保存EL2的状态（EL2h）
```

#### 原因2：EL2主动处理异常

如果EL2有异常处理程序，可能主动处理SError：
- EL2的异常向量表可能配置了SError处理
- EL2处理异常后转发到EL3

#### 原因3：时序问题

HCR_EL2的值可能在异常发生时被修改：
- 注入错误前：HCR_EL2.AMO = 0
- 异常发生时：HCR_EL2.AMO可能被临时设置为1
- 异常处理后：HCR_EL2.AMO恢复为0

## 其他关键位分析

### HCR_EL2.TGE = 1 (bit 27)

**TGE (Trap General Exceptions) = 1** 表示：
- EL2配置为捕获通用异常
- 可能影响异常路由行为

### HCR_EL2.RW = 1 (bit 31)

**RW = 1** 表示：
- EL2使用AArch64执行状态
- 这是正常的配置

## 验证方法

### 1. 检查异常发生时的HCR_EL2

在EL3异常处理函数中检查：

```c
void check_hcr_el2_at_exception(void)
{
    uint64_t hcr_el2 = read_hcr_el2();
    uint64_t scr_el3 = read_scr_el3();
    uint64_t spsr_el3 = read_spsr_el3();
    
    INFO("异常发生时的配置:\n");
    INFO("  HCR_EL2 = 0x%016llx\n", hcr_el2);
    INFO("    AMO (bit 5) = %d\n", (hcr_el2 >> 5) & 1);
    INFO("  SCR_EL3 = 0x%016llx\n", scr_el3);
    INFO("    EA (bit 3) = %d\n", (scr_el3 >> 3) & 1);
    INFO("  SPSR_EL3.M[3:0] = 0x%llx\n", spsr_el3 & 0xF);
    
    if ((hcr_el2 >> 5) & 1) {
        INFO("  -> HCR_EL2.AMO = 1，SError应该路由到EL2\n");
    } else if ((scr_el3 >> 3) & 1) {
        INFO("  -> HCR_EL2.AMO = 0 且 SCR_EL3.EA = 1\n");
        INFO("     SError应该直接路由到EL3\n");
        if ((spsr_el3 & 0xF) == 0x9) {
            WARN("     但SPSR_EL3显示EL2h，异常！\n");
            WARN("     可能EL2拦截并转发了异常\n");
        }
    }
}
```

### 2. 检查EL2的异常向量表

如果EL2有异常处理程序，可能拦截SError：

```c
// 检查EL2的VBAR_EL2
uint64_t vbar_el2 = read_vbar_el2();
INFO("VBAR_EL2 = 0x%016llx\n", vbar_el2);
// 如果设置了异常向量表，EL2可能有SError处理程序
```

### 3. 检查EL2是否启用

```c
uint64_t scr_el3 = read_scr_el3();
if (scr_el3 & SCR_HCE_BIT) {
    INFO("EL2被启用（SCR_EL3.HCE = 1）\n");
    INFO("即使HCR_EL2.AMO = 0，EL2仍可能拦截异常\n");
}
```

## 可能的原因总结

### 如果HCR_EL2.AMO = 0但SPSR_EL3显示EL2h

**可能原因**：

1. **EL2拦截异常**
   - EL2的异常向量表配置了SError处理
   - EL2主动拦截并处理异常，然后转发到EL3

2. **EL2转发机制**
   - 即使HCR_EL2.AMO = 0，EL2仍可能转发异常到EL3
   - 这是EL2的软件行为，不是硬件路由

3. **时序问题**
   - 异常发生时HCR_EL2.AMO可能被临时修改
   - 需要检查异常发生时的实际值

## 总结

**HCR_EL2 = 0x88000000 分析**：
- ✅ **HCR_EL2.AMO = 0**：SError不路由到EL2（硬件路由）
- ❓ **但SPSR_EL3显示EL2h**：说明异常在EL2处理

**结论**：
- 硬件路由配置：SError应该路由到EL3（如果SCR_EL3.EA=1）
- 但EL2可能通过软件机制拦截并转发异常
- 这是正常的，只要最终在EL3处理并终止

**需要确认**：
- EL2是否有SError处理程序
- EL2是否主动拦截异常
- 异常发生时的实际HCR_EL2值


# 动态映射失败深度分析

## 问题描述

**现象**：
- 已映射4个区域
- MAX_MMAP_REGIONS = 16
- 尝试添加第5个区域失败
- 错误信息："no enough memory to map region"

## 可能的原因分析

### 原因1：MAX_MMAP_REGIONS检查（不太可能）

**检查代码**（xlat_tables_core.c:692）：
```c
/* Check that there is space in the ctx->mmap array */
if (ctx->mmap[ctx->mmap_num - 1].size != 0U)
    return -ENOMEM;
```

**分析**：
- 如果只有4个静态映射区域，应该有12个空闲槽位
- 理论上不应该因为MAX_MMAP_REGIONS限制而失败
- **但需要确认ctx->mmap_num的实际值**

### 原因2：地址空间限制（最可能）

**检查代码**（xlat_tables_core.c:685-689）：
```c
if ((base_va + (uintptr_t)size - (uintptr_t)1) > ctx->va_max_address)
    return -ERANGE;

if ((base_pa + (unsigned long long)size - 1ULL) > ctx->pa_max_address)
    return -ERANGE;
```

**你的映射区域**：
1. 0xc000000 - 0xc000000 + 0x400000 (VA: 0xc000000, PA: 0xc000000, size: 0x400000)
2. 0x20000000 - 0x40000000 (VA: 0x20000000, PA: 0x20000000, size: 0x20000000)
3. 0xf5000 - 0x10000 (VA: 0xf5000, PA: 0xf5000, size: 0xb000)
4. 0xa2000000 - 0x10000 (VA: 0xa2000000, PA: 0xa2000000, size: 0xf000)

**问题**：
- 第2个区域：0x20000000 + 0x20000000 = 0x40000000（4GB边界）
- 如果PLAT_VIRT_ADDR_SPACE_SIZE或PLAT_PHY_ADDR_SPACE_SIZE小于4GB，会失败

### 原因3：翻译表空间不足（可能）

**检查代码**（xlat_tables_core.c:1003）：
```c
if (end_va != (mm_cursor->base_va + mm_cursor->size - 1U)) {
    // ...
    return -ENOMEM;
}
```

**问题**：
- 如果翻译表（translation tables）空间不足，也会返回ENOMEM
- MAX_XLAT_TABLES可能限制了翻译表的数量

### 原因4：映射区域重叠检查（可能）

**检查代码**（xlat_tables_core.c:696-720）：
```c
/* Check for PAs and VAs overlaps with all other regions */
for (const mmap_region_t *mm_cursor = ctx->mmap;
     mm_cursor->size != 0U; ++mm_cursor) {
    // 检查重叠
    if (overlaps) {
        return -EPERM;
    }
}
```

**问题**：
- 如果新区域与现有区域重叠，会返回-EPERM
- 但错误信息是"no enough memory"，不是"overlap"

## 诊断方法

### 方法1：检查实际使用的映射区域数量

```c
void check_mmap_usage(void)
{
    // 需要访问xlat_tables的内部结构
    // 或者添加调试接口
    tftf_testcase_printf("静态映射区域数量: %d\n", static_count);
    tftf_testcase_printf("动态映射区域数量: %d\n", dynamic_count);
    tftf_testcase_printf("MAX_MMAP_REGIONS: %d\n", MAX_MMAP_REGIONS);
}
```

### 方法2：检查地址空间限制

```c
void check_address_space_limits(void)
{
    tftf_testcase_printf("PLAT_VIRT_ADDR_SPACE_SIZE: 0x%llx\n", 
                         PLAT_VIRT_ADDR_SPACE_SIZE);
    tftf_testcase_printf("PLAT_PHY_ADDR_SPACE_SIZE: 0x%llx\n", 
                         PLAT_PHY_ADDR_SPACE_SIZE);
    
    // 检查你的映射区域是否超出限制
    uint64_t max_va = 0xa2000000 + 0xf000;  // 你的最大VA
    uint64_t max_pa = 0xa2000000 + 0xf000;  // 你的最大PA
    
    if (max_va > PLAT_VIRT_ADDR_SPACE_SIZE) {
        tftf_testcase_printf("虚拟地址超出限制！\n");
    }
    if (max_pa > PLAT_PHY_ADDR_SPACE_SIZE) {
        tftf_testcase_printf("物理地址超出限制！\n");
    }
}
```

### 方法3：检查翻译表空间

```c
void check_xlat_tables_space(void)
{
    tftf_testcase_printf("MAX_XLAT_TABLES: %d\n", MAX_XLAT_TABLES);
    tftf_testcase_printf("当前使用的翻译表数量: %d\n", current_tables);
}
```

### 方法4：打印详细的错误信息

```c
int rc = mmap_add_dynamic_region(base_pa, base_va, size, attr);
if (rc != 0) {
    tftf_testcase_printf("mmap_add_dynamic_region失败: %d\n", rc);
    if (rc == -ENOMEM) {
        tftf_testcase_printf("错误: ENOMEM - 内存不足\n");
    } else if (rc == -ERANGE) {
        tftf_testcase_printf("错误: ERANGE - 地址超出范围\n");
    } else if (rc == -EPERM) {
        tftf_testcase_printf("错误: EPERM - 区域重叠\n");
    } else if (rc == -EINVAL) {
        tftf_testcase_printf("错误: EINVAL - 无效参数\n");
    }
}
```

## 最可能的原因

### 原因A：地址空间限制（最可能）⭐⭐⭐⭐⭐

**你的第2个区域**：
- VA: 0x20000000 - 0x40000000 (512MB)
- 如果PLAT_VIRT_ADDR_SPACE_SIZE < 1GB，可能有问题

**你的第4个区域**：
- VA: 0xa2000000 - 0xa200f000
- 如果PLAT_VIRT_ADDR_SPACE_SIZE < 2.5GB，会超出限制

**检查方法**：
```c
// 在plat/arm/fvp/include/platform_def.h中检查
#define PLAT_VIRT_ADDR_SPACE_SIZE    // 应该是多少？
#define PLAT_PHY_ADDR_SPACE_SIZE     // 应该是多少？
```

### 原因B：翻译表空间不足（可能）⭐⭐⭐⭐

**问题**：
- 每个映射区域可能需要多个翻译表条目
- 如果MAX_XLAT_TABLES太小，可能无法分配新的翻译表

**检查方法**：
```c
// 检查MAX_XLAT_TABLES的值
#if IMAGE_TFTF
#define MAX_XLAT_TABLES    20  // 这个值是多少？
#endif
```

### 原因C：映射区域内部碎片（可能）⭐⭐⭐

**问题**：
- 虽然只有4个静态映射区域，但可能内部已经分配了很多动态映射
- 或者静态映射区域在添加时被分割成多个条目

## 解决方案

### 方案1：增加地址空间大小

```c
// plat/arm/fvp/include/platform_def.h
#define PLAT_VIRT_ADDR_SPACE_SIZE    (ULL(1) << 32)  // 4GB
#define PLAT_PHY_ADDR_SPACE_SIZE     (ULL(1) << 32)  // 4GB
```

### 方案2：增加MAX_XLAT_TABLES

```c
// plat/arm/fvp/include/platform_def.h
#if IMAGE_TFTF
#define MAX_XLAT_TABLES    30  // 从20增加到30
#endif
```

### 方案3：优化映射区域

**合并相邻的映射区域**：
```c
// 如果可能，合并相邻区域
// 例如：如果0xf5000和0xa2000000可以合并
```

### 方案4：检查实际错误代码

```c
int rc = mmap_add_dynamic_region(base_pa, base_va, size, attr);
tftf_testcase_printf("返回值: %d\n", rc);
tftf_testcase_printf("ENOMEM = %d\n", -ENOMEM);
tftf_testcase_printf("ERANGE = %d\n", -ERANGE);
tftf_testcase_printf("EPERM = %d\n", -EPERM);
tftf_testcase_printf("EINVAL = %d\n", -EINVAL);
```

## 具体检查步骤

### 步骤1：确认错误代码

```c
int rc = mmap_add_dynamic_region(...);
if (rc == -ENOMEM) {
    // 确实是内存不足
} else if (rc == -ERANGE) {
    // 地址超出范围
} else {
    // 其他错误
}
```

### 步骤2：检查地址空间限制

```c
// 检查你的最大地址
uint64_t max_va = 0xa2000000 + 0xf000;  // 约2.5GB
uint64_t max_pa = 0xa2000000 + 0xf000;  // 约2.5GB

// 检查是否超出PLAT_VIRT_ADDR_SPACE_SIZE和PLAT_PHY_ADDR_SPACE_SIZE
```

### 步骤3：检查翻译表空间

```c
// 检查MAX_XLAT_TABLES的值
// 如果太小，增加它
```

## 总结

**最可能的原因**：

1. **⭐⭐⭐⭐⭐ 地址空间限制**
   - PLAT_VIRT_ADDR_SPACE_SIZE或PLAT_PHY_ADDR_SPACE_SIZE太小
   - 你的第4个区域（0xa2000000）可能超出限制

2. **⭐⭐⭐⭐ 翻译表空间不足**
   - MAX_XLAT_TABLES太小
   - 无法分配新的翻译表

3. **⭐⭐⭐ 映射区域内部碎片**
   - 虽然只有4个静态映射，但可能内部已经分配了很多条目

**建议**：
1. 首先检查错误代码（确认是ENOMEM还是ERANGE）
2. 检查PLAT_VIRT_ADDR_SPACE_SIZE和PLAT_PHY_ADDR_SPACE_SIZE
3. 检查MAX_XLAT_TABLES的值
4. 根据检查结果调整相应的配置


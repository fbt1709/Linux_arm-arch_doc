# 老版本 ATF 自动编译 BL32 的解决方案

## 问题描述

在老版本的 ATF 中，即使设置了 `SPD=tspd` 和 `NEED_BL32 := yes`，执行 `make all` 时可能不会自动编译 BL32。

## 原因分析

老版本的 `MAKE_BL` 宏可能没有将 `bl32` 自动添加到 `all` 目标的依赖中，或者 `all` 目标的定义方式不同。

## 解决方案

### 方案 1：检查 MAKE_BL 宏（推荐）

检查 `make_helpers/build_macros.mk` 中的 `MAKE_BL` 宏是否包含：

```makefile
# make_helpers/build_macros.mk
define MAKE_BL
    # ... 其他代码 ...
    
    .PHONY: $(1)
    $(1): $(BIN) $(DUMP)
    
    all: $(1)  # ← 这行很重要！确保 bl32 被添加到 all 的依赖中
endef
```

**如果没有 `all: $(1)` 这一行**，需要添加它。

### 方案 2：手动修改 Makefile（如果方案 1 不行）

在 `Makefile` 中，找到 `all` 目标的定义，手动添加 `bl32` 依赖：

```makefile
# Makefile:966
all: msg_start

# 修改为（在 NEED_BL32 检查之后）：
all: msg_start
ifeq (${NEED_BL32},yes)
ifeq (${BUILD_BL32},1)
all: bl32
endif
endif
```

### 方案 3：在 SPD 的 Makefile 中显式添加（最简单）

在你的 SPD Makefile（如 `services/spd/your_spd/your_spd.mk`）中添加：

```makefile
# services/spd/your_spd/your_spd.mk

# 设置需要 BL32
NEED_BL32 := yes

# 添加 BL32 源文件
BL32_SOURCES += your_sp/bl32_main.c \
                your_sp/bl32_entrypoint.S \
                ...

# 关键：显式将 bl32 添加到 all 目标的依赖中
all: bl32
```

### 方案 4：使用显式编译命令

如果自动编译不工作，可以显式指定编译目标：

```bash
# 方法 1：同时编译 bl31 和 bl32
make PLAT=fvp SPD=your_spd bl31 bl32

# 方法 2：先编译 bl31，再编译 bl32
make PLAT=fvp SPD=your_spd bl31
make PLAT=fvp SPD=your_spd bl32

# 方法 3：使用 all 目标（如果修复了 Makefile）
make PLAT=fvp SPD=your_spd all
```

## 检查步骤

### 步骤 1：检查 MAKE_BL 宏

```bash
cd /home/fbt1709/arm-trusted-firmware
grep -A 5 "all: \$(1)" make_helpers/build_macros.mk
```

应该看到：
```makefile
all: $(1)
```

### 步骤 2：检查 all 目标依赖

```bash
# 检查 all 目标是否包含 bl32
make PLAT=fvp SPD=your_spd -n 2>&1 | grep "^all:"
```

### 步骤 3：检查 bl32 目标是否被创建

```bash
# 检查 bl32 目标是否存在
make PLAT=fvp SPD=your_spd -n 2>&1 | grep "^bl32:"
```

## 完整修复示例

假设你的 SPD 是 `my_spd`，修复步骤如下：

### 1. 创建 SPD Makefile

```makefile
# services/spd/my_spd/my_spd.mk

MY_SPD_DIR := services/spd/my_spd

SPD_SOURCES := services/spd/my_spd/my_spd_main.c \
               services/spd/my_spd/my_spd_common.c

# 设置需要 BL32
NEED_BL32 := yes

# 添加 BL32 源文件
BL32_SOURCES += bl32/my_sp/my_sp_main.c \
                bl32/my_sp/aarch64/my_sp_entrypoint.S

# 关键：确保 bl32 被编译
all: bl32
```

### 2. 验证编译

```bash
# 清理
make PLAT=fvp SPD=my_spd clean

# 编译
make PLAT=fvp SPD=my_spd all

# 检查结果
ls -lh build/fvp/release/bl32.bin
```

## 老版本特定问题

### 问题 1：MAKE_BL 宏没有添加到 all

**症状**：`make all` 不编译 bl32

**解决**：在 `make_helpers/build_macros.mk` 的 `MAKE_BL` 宏中添加：
```makefile
all: $(1)
```

### 问题 2：all 目标定义在 NEED_BL32 检查之前

**症状**：`all` 目标在 `NEED_BL32` 检查之前定义，无法添加 bl32 依赖

**解决**：将 `all` 目标的完整定义移到 `NEED_BL32` 检查之后，或者使用条件添加：
```makefile
all: msg_start
ifeq (${NEED_BL32},yes)
ifeq (${BUILD_BL32},1)
all: bl32
endif
endif
```

### 问题 3：BUILD_BL32 变量未正确设置

**症状**：即使有 `BL32_SOURCES`，`BUILD_BL32` 仍为 0

**解决**：检查 `Makefile:1020` 的逻辑：
```makefile
BUILD_BL32 := $(if $(BL32),,$(if $(BL32_SOURCES),1))
```

确保 `BL32_SOURCES` 有内容且 `BL32` 未定义。

## 调试技巧

### 1. 打印变量值

在 Makefile 中添加：
```makefile
$(info NEED_BL32 = ${NEED_BL32})
$(info BL32_SOURCES = ${BL32_SOURCES})
$(info BUILD_BL32 = ${BUILD_BL32})
```

### 2. 检查目标依赖

```bash
# 查看 all 目标的依赖
make PLAT=fvp SPD=your_spd -n 2>&1 | grep "^all:"

# 查看 bl32 目标的依赖
make PLAT=fvp SPD=your_spd -n 2>&1 | grep "^bl32:"
```

### 3. 手动测试编译

```bash
# 直接编译 bl32
make PLAT=fvp SPD=your_spd bl32

# 如果成功，说明问题在于 all 目标没有包含 bl32
```

## 推荐方案

**最简单可靠的方法**：在你的 SPD Makefile 末尾添加：

```makefile
# 确保 bl32 被编译
ifeq (${NEED_BL32},yes)
ifeq (${BUILD_BL32},1)
all: bl32
endif
endif
```

这样无论 ATF 版本如何，都能确保 bl32 被编译。

